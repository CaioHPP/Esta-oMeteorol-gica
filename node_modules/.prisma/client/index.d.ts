
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/index';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model Leitura
 * 
 */
export type Leitura = {
  id: number
  createdAt: Date
}

/**
 * Model Temperatura
 * 
 */
export type Temperatura = {
  id: number
  sensor: string
  valor: number
  unidade: string
  ordemGrandeza: number
  leituraId: number
}

/**
 * Model Pressao
 * 
 */
export type Pressao = {
  id: number
  sensor: string
  valor: number
  unidade: string
  ordemGrandeza: number
  leituraId: number
}

/**
 * Model Altitude
 * 
 */
export type Altitude = {
  id: number
  sensor: string
  valor: number
  unidade: string
  ordemGrandeza: number
  leituraId: number
}

/**
 * Model VelocidadeVento
 * 
 */
export type VelocidadeVento = {
  id: number
  sensor: string
  media: number
  maximo: number
  unidade: string
  ordemGrandeza: number
  leituraId: number
}

/**
 * Model DirecaoVento
 * 
 */
export type DirecaoVento = {
  id: number
  sensor: string
  valor: number
  unidade: string
  ordemGrandeza: number
  leituraId: number
}

/**
 * Model Precipitacao
 * 
 */
export type Precipitacao = {
  id: number
  sensor: string
  valor: number
  unidade: string
  ordemGrandeza: number
  leituraId: number
}

/**
 * Model UmidadeSolo
 * 
 */
export type UmidadeSolo = {
  id: number
  sensor: string
  valor: number
  unidade: string
  ordemGrandeza: number
  leituraId: number
}

/**
 * Model UmidadeRelativa
 * 
 */
export type UmidadeRelativa = {
  id: number
  sensor: string
  valor: number
  unidade: string
  ordemGrandeza: number
  leituraId: number
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Leituras
 * const leituras = await prisma.leitura.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Leituras
   * const leituras = await prisma.leitura.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>;

      /**
   * `prisma.leitura`: Exposes CRUD operations for the **Leitura** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Leituras
    * const leituras = await prisma.leitura.findMany()
    * ```
    */
  get leitura(): Prisma.LeituraDelegate<GlobalReject>;

  /**
   * `prisma.temperatura`: Exposes CRUD operations for the **Temperatura** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Temperaturas
    * const temperaturas = await prisma.temperatura.findMany()
    * ```
    */
  get temperatura(): Prisma.TemperaturaDelegate<GlobalReject>;

  /**
   * `prisma.pressao`: Exposes CRUD operations for the **Pressao** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pressaos
    * const pressaos = await prisma.pressao.findMany()
    * ```
    */
  get pressao(): Prisma.PressaoDelegate<GlobalReject>;

  /**
   * `prisma.altitude`: Exposes CRUD operations for the **Altitude** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Altitudes
    * const altitudes = await prisma.altitude.findMany()
    * ```
    */
  get altitude(): Prisma.AltitudeDelegate<GlobalReject>;

  /**
   * `prisma.velocidadeVento`: Exposes CRUD operations for the **VelocidadeVento** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VelocidadeVentos
    * const velocidadeVentos = await prisma.velocidadeVento.findMany()
    * ```
    */
  get velocidadeVento(): Prisma.VelocidadeVentoDelegate<GlobalReject>;

  /**
   * `prisma.direcaoVento`: Exposes CRUD operations for the **DirecaoVento** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DirecaoVentos
    * const direcaoVentos = await prisma.direcaoVento.findMany()
    * ```
    */
  get direcaoVento(): Prisma.DirecaoVentoDelegate<GlobalReject>;

  /**
   * `prisma.precipitacao`: Exposes CRUD operations for the **Precipitacao** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Precipitacaos
    * const precipitacaos = await prisma.precipitacao.findMany()
    * ```
    */
  get precipitacao(): Prisma.PrecipitacaoDelegate<GlobalReject>;

  /**
   * `prisma.umidadeSolo`: Exposes CRUD operations for the **UmidadeSolo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UmidadeSolos
    * const umidadeSolos = await prisma.umidadeSolo.findMany()
    * ```
    */
  get umidadeSolo(): Prisma.UmidadeSoloDelegate<GlobalReject>;

  /**
   * `prisma.umidadeRelativa`: Exposes CRUD operations for the **UmidadeRelativa** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UmidadeRelativas
    * const umidadeRelativas = await prisma.umidadeRelativa.findMany()
    * ```
    */
  get umidadeRelativa(): Prisma.UmidadeRelativaDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  /**
   * Prisma Client JS version: 3.14.0
   * Query Engine version: 2b0c12756921c891fec4f68d9444e18c7d5d4a6a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: 'DbNull'

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: 'JsonNull'

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: 'AnyNull'

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Buffer
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    Leitura: 'Leitura',
    Temperatura: 'Temperatura',
    Pressao: 'Pressao',
    Altitude: 'Altitude',
    VelocidadeVento: 'VelocidadeVento',
    DirecaoVento: 'DirecaoVento',
    Precipitacao: 'Precipitacao',
    UmidadeSolo: 'UmidadeSolo',
    UmidadeRelativa: 'UmidadeRelativa'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     *  * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your prisma.schema file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type LeituraCountOutputType
   */


  export type LeituraCountOutputType = {
    Temperatura: number
    Pressao: number
    Altitude: number
    VelocidadeVento: number
    DirecaoVento: number
    Precipitacao: number
    UmidadeSolo: number
    UmidadeRelativa: number
  }

  export type LeituraCountOutputTypeSelect = {
    Temperatura?: boolean
    Pressao?: boolean
    Altitude?: boolean
    VelocidadeVento?: boolean
    DirecaoVento?: boolean
    Precipitacao?: boolean
    UmidadeSolo?: boolean
    UmidadeRelativa?: boolean
  }

  export type LeituraCountOutputTypeGetPayload<
    S extends boolean | null | undefined | LeituraCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? LeituraCountOutputType
    : S extends undefined
    ? never
    : S extends LeituraCountOutputTypeArgs
    ?'include' extends U
    ? LeituraCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof LeituraCountOutputType ? LeituraCountOutputType[P] : never
  } 
    : LeituraCountOutputType
  : LeituraCountOutputType




  // Custom InputTypes

  /**
   * LeituraCountOutputType without action
   */
  export type LeituraCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the LeituraCountOutputType
     * 
    **/
    select?: LeituraCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model Leitura
   */


  export type AggregateLeitura = {
    _count: LeituraCountAggregateOutputType | null
    _avg: LeituraAvgAggregateOutputType | null
    _sum: LeituraSumAggregateOutputType | null
    _min: LeituraMinAggregateOutputType | null
    _max: LeituraMaxAggregateOutputType | null
  }

  export type LeituraAvgAggregateOutputType = {
    id: number | null
  }

  export type LeituraSumAggregateOutputType = {
    id: number | null
  }

  export type LeituraMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
  }

  export type LeituraMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
  }

  export type LeituraCountAggregateOutputType = {
    id: number
    createdAt: number
    _all: number
  }


  export type LeituraAvgAggregateInputType = {
    id?: true
  }

  export type LeituraSumAggregateInputType = {
    id?: true
  }

  export type LeituraMinAggregateInputType = {
    id?: true
    createdAt?: true
  }

  export type LeituraMaxAggregateInputType = {
    id?: true
    createdAt?: true
  }

  export type LeituraCountAggregateInputType = {
    id?: true
    createdAt?: true
    _all?: true
  }

  export type LeituraAggregateArgs = {
    /**
     * Filter which Leitura to aggregate.
     * 
    **/
    where?: LeituraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leituras to fetch.
     * 
    **/
    orderBy?: Enumerable<LeituraOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: LeituraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leituras from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leituras.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Leituras
    **/
    _count?: true | LeituraCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeituraAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeituraSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeituraMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeituraMaxAggregateInputType
  }

  export type GetLeituraAggregateType<T extends LeituraAggregateArgs> = {
        [P in keyof T & keyof AggregateLeitura]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeitura[P]>
      : GetScalarType<T[P], AggregateLeitura[P]>
  }




  export type LeituraGroupByArgs = {
    where?: LeituraWhereInput
    orderBy?: Enumerable<LeituraOrderByWithAggregationInput>
    by: Array<LeituraScalarFieldEnum>
    having?: LeituraScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeituraCountAggregateInputType | true
    _avg?: LeituraAvgAggregateInputType
    _sum?: LeituraSumAggregateInputType
    _min?: LeituraMinAggregateInputType
    _max?: LeituraMaxAggregateInputType
  }


  export type LeituraGroupByOutputType = {
    id: number
    createdAt: Date
    _count: LeituraCountAggregateOutputType | null
    _avg: LeituraAvgAggregateOutputType | null
    _sum: LeituraSumAggregateOutputType | null
    _min: LeituraMinAggregateOutputType | null
    _max: LeituraMaxAggregateOutputType | null
  }

  type GetLeituraGroupByPayload<T extends LeituraGroupByArgs> = PrismaPromise<
    Array<
      PickArray<LeituraGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeituraGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeituraGroupByOutputType[P]>
            : GetScalarType<T[P], LeituraGroupByOutputType[P]>
        }
      >
    >


  export type LeituraSelect = {
    id?: boolean
    createdAt?: boolean
    Temperatura?: boolean | TemperaturaFindManyArgs
    Pressao?: boolean | PressaoFindManyArgs
    Altitude?: boolean | AltitudeFindManyArgs
    VelocidadeVento?: boolean | VelocidadeVentoFindManyArgs
    DirecaoVento?: boolean | DirecaoVentoFindManyArgs
    Precipitacao?: boolean | PrecipitacaoFindManyArgs
    UmidadeSolo?: boolean | UmidadeSoloFindManyArgs
    UmidadeRelativa?: boolean | UmidadeRelativaFindManyArgs
    _count?: boolean | LeituraCountOutputTypeArgs
  }

  export type LeituraInclude = {
    Temperatura?: boolean | TemperaturaFindManyArgs
    Pressao?: boolean | PressaoFindManyArgs
    Altitude?: boolean | AltitudeFindManyArgs
    VelocidadeVento?: boolean | VelocidadeVentoFindManyArgs
    DirecaoVento?: boolean | DirecaoVentoFindManyArgs
    Precipitacao?: boolean | PrecipitacaoFindManyArgs
    UmidadeSolo?: boolean | UmidadeSoloFindManyArgs
    UmidadeRelativa?: boolean | UmidadeRelativaFindManyArgs
    _count?: boolean | LeituraCountOutputTypeArgs
  }

  export type LeituraGetPayload<
    S extends boolean | null | undefined | LeituraArgs,
    U = keyof S
      > = S extends true
        ? Leitura
    : S extends undefined
    ? never
    : S extends LeituraArgs | LeituraFindManyArgs
    ?'include' extends U
    ? Leitura  & {
    [P in TrueKeys<S['include']>]:
        P extends 'Temperatura' ? Array < TemperaturaGetPayload<S['include'][P]>>  :
        P extends 'Pressao' ? Array < PressaoGetPayload<S['include'][P]>>  :
        P extends 'Altitude' ? Array < AltitudeGetPayload<S['include'][P]>>  :
        P extends 'VelocidadeVento' ? Array < VelocidadeVentoGetPayload<S['include'][P]>>  :
        P extends 'DirecaoVento' ? Array < DirecaoVentoGetPayload<S['include'][P]>>  :
        P extends 'Precipitacao' ? Array < PrecipitacaoGetPayload<S['include'][P]>>  :
        P extends 'UmidadeSolo' ? Array < UmidadeSoloGetPayload<S['include'][P]>>  :
        P extends 'UmidadeRelativa' ? Array < UmidadeRelativaGetPayload<S['include'][P]>>  :
        P extends '_count' ? LeituraCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'Temperatura' ? Array < TemperaturaGetPayload<S['select'][P]>>  :
        P extends 'Pressao' ? Array < PressaoGetPayload<S['select'][P]>>  :
        P extends 'Altitude' ? Array < AltitudeGetPayload<S['select'][P]>>  :
        P extends 'VelocidadeVento' ? Array < VelocidadeVentoGetPayload<S['select'][P]>>  :
        P extends 'DirecaoVento' ? Array < DirecaoVentoGetPayload<S['select'][P]>>  :
        P extends 'Precipitacao' ? Array < PrecipitacaoGetPayload<S['select'][P]>>  :
        P extends 'UmidadeSolo' ? Array < UmidadeSoloGetPayload<S['select'][P]>>  :
        P extends 'UmidadeRelativa' ? Array < UmidadeRelativaGetPayload<S['select'][P]>>  :
        P extends '_count' ? LeituraCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Leitura ? Leitura[P] : never
  } 
    : Leitura
  : Leitura


  type LeituraCountArgs = Merge<
    Omit<LeituraFindManyArgs, 'select' | 'include'> & {
      select?: LeituraCountAggregateInputType | true
    }
  >

  export interface LeituraDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Leitura that matches the filter.
     * @param {LeituraFindUniqueArgs} args - Arguments to find a Leitura
     * @example
     * // Get one Leitura
     * const leitura = await prisma.leitura.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LeituraFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LeituraFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Leitura'> extends True ? CheckSelect<T, Prisma__LeituraClient<Leitura>, Prisma__LeituraClient<LeituraGetPayload<T>>> : CheckSelect<T, Prisma__LeituraClient<Leitura | null >, Prisma__LeituraClient<LeituraGetPayload<T> | null >>

    /**
     * Find the first Leitura that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeituraFindFirstArgs} args - Arguments to find a Leitura
     * @example
     * // Get one Leitura
     * const leitura = await prisma.leitura.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LeituraFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LeituraFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Leitura'> extends True ? CheckSelect<T, Prisma__LeituraClient<Leitura>, Prisma__LeituraClient<LeituraGetPayload<T>>> : CheckSelect<T, Prisma__LeituraClient<Leitura | null >, Prisma__LeituraClient<LeituraGetPayload<T> | null >>

    /**
     * Find zero or more Leituras that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeituraFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Leituras
     * const leituras = await prisma.leitura.findMany()
     * 
     * // Get first 10 Leituras
     * const leituras = await prisma.leitura.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leituraWithIdOnly = await prisma.leitura.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LeituraFindManyArgs>(
      args?: SelectSubset<T, LeituraFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Leitura>>, PrismaPromise<Array<LeituraGetPayload<T>>>>

    /**
     * Create a Leitura.
     * @param {LeituraCreateArgs} args - Arguments to create a Leitura.
     * @example
     * // Create one Leitura
     * const Leitura = await prisma.leitura.create({
     *   data: {
     *     // ... data to create a Leitura
     *   }
     * })
     * 
    **/
    create<T extends LeituraCreateArgs>(
      args: SelectSubset<T, LeituraCreateArgs>
    ): CheckSelect<T, Prisma__LeituraClient<Leitura>, Prisma__LeituraClient<LeituraGetPayload<T>>>

    /**
     * Delete a Leitura.
     * @param {LeituraDeleteArgs} args - Arguments to delete one Leitura.
     * @example
     * // Delete one Leitura
     * const Leitura = await prisma.leitura.delete({
     *   where: {
     *     // ... filter to delete one Leitura
     *   }
     * })
     * 
    **/
    delete<T extends LeituraDeleteArgs>(
      args: SelectSubset<T, LeituraDeleteArgs>
    ): CheckSelect<T, Prisma__LeituraClient<Leitura>, Prisma__LeituraClient<LeituraGetPayload<T>>>

    /**
     * Update one Leitura.
     * @param {LeituraUpdateArgs} args - Arguments to update one Leitura.
     * @example
     * // Update one Leitura
     * const leitura = await prisma.leitura.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LeituraUpdateArgs>(
      args: SelectSubset<T, LeituraUpdateArgs>
    ): CheckSelect<T, Prisma__LeituraClient<Leitura>, Prisma__LeituraClient<LeituraGetPayload<T>>>

    /**
     * Delete zero or more Leituras.
     * @param {LeituraDeleteManyArgs} args - Arguments to filter Leituras to delete.
     * @example
     * // Delete a few Leituras
     * const { count } = await prisma.leitura.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LeituraDeleteManyArgs>(
      args?: SelectSubset<T, LeituraDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leituras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeituraUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Leituras
     * const leitura = await prisma.leitura.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LeituraUpdateManyArgs>(
      args: SelectSubset<T, LeituraUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Leitura.
     * @param {LeituraUpsertArgs} args - Arguments to update or create a Leitura.
     * @example
     * // Update or create a Leitura
     * const leitura = await prisma.leitura.upsert({
     *   create: {
     *     // ... data to create a Leitura
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Leitura we want to update
     *   }
     * })
    **/
    upsert<T extends LeituraUpsertArgs>(
      args: SelectSubset<T, LeituraUpsertArgs>
    ): CheckSelect<T, Prisma__LeituraClient<Leitura>, Prisma__LeituraClient<LeituraGetPayload<T>>>

    /**
     * Count the number of Leituras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeituraCountArgs} args - Arguments to filter Leituras to count.
     * @example
     * // Count the number of Leituras
     * const count = await prisma.leitura.count({
     *   where: {
     *     // ... the filter for the Leituras we want to count
     *   }
     * })
    **/
    count<T extends LeituraCountArgs>(
      args?: Subset<T, LeituraCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeituraCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Leitura.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeituraAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeituraAggregateArgs>(args: Subset<T, LeituraAggregateArgs>): PrismaPromise<GetLeituraAggregateType<T>>

    /**
     * Group by Leitura.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeituraGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeituraGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeituraGroupByArgs['orderBy'] }
        : { orderBy?: LeituraGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeituraGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeituraGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Leitura.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LeituraClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    Temperatura<T extends TemperaturaFindManyArgs = {}>(args?: Subset<T, TemperaturaFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Temperatura>>, PrismaPromise<Array<TemperaturaGetPayload<T>>>>;

    Pressao<T extends PressaoFindManyArgs = {}>(args?: Subset<T, PressaoFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Pressao>>, PrismaPromise<Array<PressaoGetPayload<T>>>>;

    Altitude<T extends AltitudeFindManyArgs = {}>(args?: Subset<T, AltitudeFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Altitude>>, PrismaPromise<Array<AltitudeGetPayload<T>>>>;

    VelocidadeVento<T extends VelocidadeVentoFindManyArgs = {}>(args?: Subset<T, VelocidadeVentoFindManyArgs>): CheckSelect<T, PrismaPromise<Array<VelocidadeVento>>, PrismaPromise<Array<VelocidadeVentoGetPayload<T>>>>;

    DirecaoVento<T extends DirecaoVentoFindManyArgs = {}>(args?: Subset<T, DirecaoVentoFindManyArgs>): CheckSelect<T, PrismaPromise<Array<DirecaoVento>>, PrismaPromise<Array<DirecaoVentoGetPayload<T>>>>;

    Precipitacao<T extends PrecipitacaoFindManyArgs = {}>(args?: Subset<T, PrecipitacaoFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Precipitacao>>, PrismaPromise<Array<PrecipitacaoGetPayload<T>>>>;

    UmidadeSolo<T extends UmidadeSoloFindManyArgs = {}>(args?: Subset<T, UmidadeSoloFindManyArgs>): CheckSelect<T, PrismaPromise<Array<UmidadeSolo>>, PrismaPromise<Array<UmidadeSoloGetPayload<T>>>>;

    UmidadeRelativa<T extends UmidadeRelativaFindManyArgs = {}>(args?: Subset<T, UmidadeRelativaFindManyArgs>): CheckSelect<T, PrismaPromise<Array<UmidadeRelativa>>, PrismaPromise<Array<UmidadeRelativaGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Leitura findUnique
   */
  export type LeituraFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Leitura
     * 
    **/
    select?: LeituraSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LeituraInclude | null
    /**
     * Throw an Error if a Leitura can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Leitura to fetch.
     * 
    **/
    where: LeituraWhereUniqueInput
  }


  /**
   * Leitura findFirst
   */
  export type LeituraFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Leitura
     * 
    **/
    select?: LeituraSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LeituraInclude | null
    /**
     * Throw an Error if a Leitura can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Leitura to fetch.
     * 
    **/
    where?: LeituraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leituras to fetch.
     * 
    **/
    orderBy?: Enumerable<LeituraOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leituras.
     * 
    **/
    cursor?: LeituraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leituras from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leituras.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leituras.
     * 
    **/
    distinct?: Enumerable<LeituraScalarFieldEnum>
  }


  /**
   * Leitura findMany
   */
  export type LeituraFindManyArgs = {
    /**
     * Select specific fields to fetch from the Leitura
     * 
    **/
    select?: LeituraSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LeituraInclude | null
    /**
     * Filter, which Leituras to fetch.
     * 
    **/
    where?: LeituraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leituras to fetch.
     * 
    **/
    orderBy?: Enumerable<LeituraOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Leituras.
     * 
    **/
    cursor?: LeituraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leituras from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leituras.
     * 
    **/
    skip?: number
    distinct?: Enumerable<LeituraScalarFieldEnum>
  }


  /**
   * Leitura create
   */
  export type LeituraCreateArgs = {
    /**
     * Select specific fields to fetch from the Leitura
     * 
    **/
    select?: LeituraSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LeituraInclude | null
    /**
     * The data needed to create a Leitura.
     * 
    **/
    data: XOR<LeituraCreateInput, LeituraUncheckedCreateInput>
  }


  /**
   * Leitura update
   */
  export type LeituraUpdateArgs = {
    /**
     * Select specific fields to fetch from the Leitura
     * 
    **/
    select?: LeituraSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LeituraInclude | null
    /**
     * The data needed to update a Leitura.
     * 
    **/
    data: XOR<LeituraUpdateInput, LeituraUncheckedUpdateInput>
    /**
     * Choose, which Leitura to update.
     * 
    **/
    where: LeituraWhereUniqueInput
  }


  /**
   * Leitura updateMany
   */
  export type LeituraUpdateManyArgs = {
    /**
     * The data used to update Leituras.
     * 
    **/
    data: XOR<LeituraUpdateManyMutationInput, LeituraUncheckedUpdateManyInput>
    /**
     * Filter which Leituras to update
     * 
    **/
    where?: LeituraWhereInput
  }


  /**
   * Leitura upsert
   */
  export type LeituraUpsertArgs = {
    /**
     * Select specific fields to fetch from the Leitura
     * 
    **/
    select?: LeituraSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LeituraInclude | null
    /**
     * The filter to search for the Leitura to update in case it exists.
     * 
    **/
    where: LeituraWhereUniqueInput
    /**
     * In case the Leitura found by the `where` argument doesn't exist, create a new Leitura with this data.
     * 
    **/
    create: XOR<LeituraCreateInput, LeituraUncheckedCreateInput>
    /**
     * In case the Leitura was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<LeituraUpdateInput, LeituraUncheckedUpdateInput>
  }


  /**
   * Leitura delete
   */
  export type LeituraDeleteArgs = {
    /**
     * Select specific fields to fetch from the Leitura
     * 
    **/
    select?: LeituraSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LeituraInclude | null
    /**
     * Filter which Leitura to delete.
     * 
    **/
    where: LeituraWhereUniqueInput
  }


  /**
   * Leitura deleteMany
   */
  export type LeituraDeleteManyArgs = {
    /**
     * Filter which Leituras to delete
     * 
    **/
    where?: LeituraWhereInput
  }


  /**
   * Leitura without action
   */
  export type LeituraArgs = {
    /**
     * Select specific fields to fetch from the Leitura
     * 
    **/
    select?: LeituraSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LeituraInclude | null
  }



  /**
   * Model Temperatura
   */


  export type AggregateTemperatura = {
    _count: TemperaturaCountAggregateOutputType | null
    _avg: TemperaturaAvgAggregateOutputType | null
    _sum: TemperaturaSumAggregateOutputType | null
    _min: TemperaturaMinAggregateOutputType | null
    _max: TemperaturaMaxAggregateOutputType | null
  }

  export type TemperaturaAvgAggregateOutputType = {
    id: number | null
    valor: number | null
    ordemGrandeza: number | null
    leituraId: number | null
  }

  export type TemperaturaSumAggregateOutputType = {
    id: number | null
    valor: number | null
    ordemGrandeza: number | null
    leituraId: number | null
  }

  export type TemperaturaMinAggregateOutputType = {
    id: number | null
    sensor: string | null
    valor: number | null
    unidade: string | null
    ordemGrandeza: number | null
    leituraId: number | null
  }

  export type TemperaturaMaxAggregateOutputType = {
    id: number | null
    sensor: string | null
    valor: number | null
    unidade: string | null
    ordemGrandeza: number | null
    leituraId: number | null
  }

  export type TemperaturaCountAggregateOutputType = {
    id: number
    sensor: number
    valor: number
    unidade: number
    ordemGrandeza: number
    leituraId: number
    _all: number
  }


  export type TemperaturaAvgAggregateInputType = {
    id?: true
    valor?: true
    ordemGrandeza?: true
    leituraId?: true
  }

  export type TemperaturaSumAggregateInputType = {
    id?: true
    valor?: true
    ordemGrandeza?: true
    leituraId?: true
  }

  export type TemperaturaMinAggregateInputType = {
    id?: true
    sensor?: true
    valor?: true
    unidade?: true
    ordemGrandeza?: true
    leituraId?: true
  }

  export type TemperaturaMaxAggregateInputType = {
    id?: true
    sensor?: true
    valor?: true
    unidade?: true
    ordemGrandeza?: true
    leituraId?: true
  }

  export type TemperaturaCountAggregateInputType = {
    id?: true
    sensor?: true
    valor?: true
    unidade?: true
    ordemGrandeza?: true
    leituraId?: true
    _all?: true
  }

  export type TemperaturaAggregateArgs = {
    /**
     * Filter which Temperatura to aggregate.
     * 
    **/
    where?: TemperaturaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Temperaturas to fetch.
     * 
    **/
    orderBy?: Enumerable<TemperaturaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: TemperaturaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Temperaturas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Temperaturas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Temperaturas
    **/
    _count?: true | TemperaturaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TemperaturaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TemperaturaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TemperaturaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TemperaturaMaxAggregateInputType
  }

  export type GetTemperaturaAggregateType<T extends TemperaturaAggregateArgs> = {
        [P in keyof T & keyof AggregateTemperatura]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTemperatura[P]>
      : GetScalarType<T[P], AggregateTemperatura[P]>
  }




  export type TemperaturaGroupByArgs = {
    where?: TemperaturaWhereInput
    orderBy?: Enumerable<TemperaturaOrderByWithAggregationInput>
    by: Array<TemperaturaScalarFieldEnum>
    having?: TemperaturaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TemperaturaCountAggregateInputType | true
    _avg?: TemperaturaAvgAggregateInputType
    _sum?: TemperaturaSumAggregateInputType
    _min?: TemperaturaMinAggregateInputType
    _max?: TemperaturaMaxAggregateInputType
  }


  export type TemperaturaGroupByOutputType = {
    id: number
    sensor: string
    valor: number
    unidade: string
    ordemGrandeza: number
    leituraId: number
    _count: TemperaturaCountAggregateOutputType | null
    _avg: TemperaturaAvgAggregateOutputType | null
    _sum: TemperaturaSumAggregateOutputType | null
    _min: TemperaturaMinAggregateOutputType | null
    _max: TemperaturaMaxAggregateOutputType | null
  }

  type GetTemperaturaGroupByPayload<T extends TemperaturaGroupByArgs> = PrismaPromise<
    Array<
      PickArray<TemperaturaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TemperaturaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TemperaturaGroupByOutputType[P]>
            : GetScalarType<T[P], TemperaturaGroupByOutputType[P]>
        }
      >
    >


  export type TemperaturaSelect = {
    id?: boolean
    sensor?: boolean
    valor?: boolean
    unidade?: boolean
    ordemGrandeza?: boolean
    leituraId?: boolean
    leitura?: boolean | LeituraArgs
  }

  export type TemperaturaInclude = {
    leitura?: boolean | LeituraArgs
  }

  export type TemperaturaGetPayload<
    S extends boolean | null | undefined | TemperaturaArgs,
    U = keyof S
      > = S extends true
        ? Temperatura
    : S extends undefined
    ? never
    : S extends TemperaturaArgs | TemperaturaFindManyArgs
    ?'include' extends U
    ? Temperatura  & {
    [P in TrueKeys<S['include']>]:
        P extends 'leitura' ? LeituraGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'leitura' ? LeituraGetPayload<S['select'][P]> :  P extends keyof Temperatura ? Temperatura[P] : never
  } 
    : Temperatura
  : Temperatura


  type TemperaturaCountArgs = Merge<
    Omit<TemperaturaFindManyArgs, 'select' | 'include'> & {
      select?: TemperaturaCountAggregateInputType | true
    }
  >

  export interface TemperaturaDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Temperatura that matches the filter.
     * @param {TemperaturaFindUniqueArgs} args - Arguments to find a Temperatura
     * @example
     * // Get one Temperatura
     * const temperatura = await prisma.temperatura.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TemperaturaFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TemperaturaFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Temperatura'> extends True ? CheckSelect<T, Prisma__TemperaturaClient<Temperatura>, Prisma__TemperaturaClient<TemperaturaGetPayload<T>>> : CheckSelect<T, Prisma__TemperaturaClient<Temperatura | null >, Prisma__TemperaturaClient<TemperaturaGetPayload<T> | null >>

    /**
     * Find the first Temperatura that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemperaturaFindFirstArgs} args - Arguments to find a Temperatura
     * @example
     * // Get one Temperatura
     * const temperatura = await prisma.temperatura.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TemperaturaFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TemperaturaFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Temperatura'> extends True ? CheckSelect<T, Prisma__TemperaturaClient<Temperatura>, Prisma__TemperaturaClient<TemperaturaGetPayload<T>>> : CheckSelect<T, Prisma__TemperaturaClient<Temperatura | null >, Prisma__TemperaturaClient<TemperaturaGetPayload<T> | null >>

    /**
     * Find zero or more Temperaturas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemperaturaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Temperaturas
     * const temperaturas = await prisma.temperatura.findMany()
     * 
     * // Get first 10 Temperaturas
     * const temperaturas = await prisma.temperatura.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const temperaturaWithIdOnly = await prisma.temperatura.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TemperaturaFindManyArgs>(
      args?: SelectSubset<T, TemperaturaFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Temperatura>>, PrismaPromise<Array<TemperaturaGetPayload<T>>>>

    /**
     * Create a Temperatura.
     * @param {TemperaturaCreateArgs} args - Arguments to create a Temperatura.
     * @example
     * // Create one Temperatura
     * const Temperatura = await prisma.temperatura.create({
     *   data: {
     *     // ... data to create a Temperatura
     *   }
     * })
     * 
    **/
    create<T extends TemperaturaCreateArgs>(
      args: SelectSubset<T, TemperaturaCreateArgs>
    ): CheckSelect<T, Prisma__TemperaturaClient<Temperatura>, Prisma__TemperaturaClient<TemperaturaGetPayload<T>>>

    /**
     * Delete a Temperatura.
     * @param {TemperaturaDeleteArgs} args - Arguments to delete one Temperatura.
     * @example
     * // Delete one Temperatura
     * const Temperatura = await prisma.temperatura.delete({
     *   where: {
     *     // ... filter to delete one Temperatura
     *   }
     * })
     * 
    **/
    delete<T extends TemperaturaDeleteArgs>(
      args: SelectSubset<T, TemperaturaDeleteArgs>
    ): CheckSelect<T, Prisma__TemperaturaClient<Temperatura>, Prisma__TemperaturaClient<TemperaturaGetPayload<T>>>

    /**
     * Update one Temperatura.
     * @param {TemperaturaUpdateArgs} args - Arguments to update one Temperatura.
     * @example
     * // Update one Temperatura
     * const temperatura = await prisma.temperatura.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TemperaturaUpdateArgs>(
      args: SelectSubset<T, TemperaturaUpdateArgs>
    ): CheckSelect<T, Prisma__TemperaturaClient<Temperatura>, Prisma__TemperaturaClient<TemperaturaGetPayload<T>>>

    /**
     * Delete zero or more Temperaturas.
     * @param {TemperaturaDeleteManyArgs} args - Arguments to filter Temperaturas to delete.
     * @example
     * // Delete a few Temperaturas
     * const { count } = await prisma.temperatura.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TemperaturaDeleteManyArgs>(
      args?: SelectSubset<T, TemperaturaDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Temperaturas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemperaturaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Temperaturas
     * const temperatura = await prisma.temperatura.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TemperaturaUpdateManyArgs>(
      args: SelectSubset<T, TemperaturaUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Temperatura.
     * @param {TemperaturaUpsertArgs} args - Arguments to update or create a Temperatura.
     * @example
     * // Update or create a Temperatura
     * const temperatura = await prisma.temperatura.upsert({
     *   create: {
     *     // ... data to create a Temperatura
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Temperatura we want to update
     *   }
     * })
    **/
    upsert<T extends TemperaturaUpsertArgs>(
      args: SelectSubset<T, TemperaturaUpsertArgs>
    ): CheckSelect<T, Prisma__TemperaturaClient<Temperatura>, Prisma__TemperaturaClient<TemperaturaGetPayload<T>>>

    /**
     * Count the number of Temperaturas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemperaturaCountArgs} args - Arguments to filter Temperaturas to count.
     * @example
     * // Count the number of Temperaturas
     * const count = await prisma.temperatura.count({
     *   where: {
     *     // ... the filter for the Temperaturas we want to count
     *   }
     * })
    **/
    count<T extends TemperaturaCountArgs>(
      args?: Subset<T, TemperaturaCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TemperaturaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Temperatura.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemperaturaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TemperaturaAggregateArgs>(args: Subset<T, TemperaturaAggregateArgs>): PrismaPromise<GetTemperaturaAggregateType<T>>

    /**
     * Group by Temperatura.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemperaturaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TemperaturaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TemperaturaGroupByArgs['orderBy'] }
        : { orderBy?: TemperaturaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TemperaturaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTemperaturaGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Temperatura.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TemperaturaClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    leitura<T extends LeituraArgs = {}>(args?: Subset<T, LeituraArgs>): CheckSelect<T, Prisma__LeituraClient<Leitura | null >, Prisma__LeituraClient<LeituraGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Temperatura findUnique
   */
  export type TemperaturaFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Temperatura
     * 
    **/
    select?: TemperaturaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TemperaturaInclude | null
    /**
     * Throw an Error if a Temperatura can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Temperatura to fetch.
     * 
    **/
    where: TemperaturaWhereUniqueInput
  }


  /**
   * Temperatura findFirst
   */
  export type TemperaturaFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Temperatura
     * 
    **/
    select?: TemperaturaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TemperaturaInclude | null
    /**
     * Throw an Error if a Temperatura can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Temperatura to fetch.
     * 
    **/
    where?: TemperaturaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Temperaturas to fetch.
     * 
    **/
    orderBy?: Enumerable<TemperaturaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Temperaturas.
     * 
    **/
    cursor?: TemperaturaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Temperaturas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Temperaturas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Temperaturas.
     * 
    **/
    distinct?: Enumerable<TemperaturaScalarFieldEnum>
  }


  /**
   * Temperatura findMany
   */
  export type TemperaturaFindManyArgs = {
    /**
     * Select specific fields to fetch from the Temperatura
     * 
    **/
    select?: TemperaturaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TemperaturaInclude | null
    /**
     * Filter, which Temperaturas to fetch.
     * 
    **/
    where?: TemperaturaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Temperaturas to fetch.
     * 
    **/
    orderBy?: Enumerable<TemperaturaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Temperaturas.
     * 
    **/
    cursor?: TemperaturaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Temperaturas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Temperaturas.
     * 
    **/
    skip?: number
    distinct?: Enumerable<TemperaturaScalarFieldEnum>
  }


  /**
   * Temperatura create
   */
  export type TemperaturaCreateArgs = {
    /**
     * Select specific fields to fetch from the Temperatura
     * 
    **/
    select?: TemperaturaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TemperaturaInclude | null
    /**
     * The data needed to create a Temperatura.
     * 
    **/
    data: XOR<TemperaturaCreateInput, TemperaturaUncheckedCreateInput>
  }


  /**
   * Temperatura update
   */
  export type TemperaturaUpdateArgs = {
    /**
     * Select specific fields to fetch from the Temperatura
     * 
    **/
    select?: TemperaturaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TemperaturaInclude | null
    /**
     * The data needed to update a Temperatura.
     * 
    **/
    data: XOR<TemperaturaUpdateInput, TemperaturaUncheckedUpdateInput>
    /**
     * Choose, which Temperatura to update.
     * 
    **/
    where: TemperaturaWhereUniqueInput
  }


  /**
   * Temperatura updateMany
   */
  export type TemperaturaUpdateManyArgs = {
    /**
     * The data used to update Temperaturas.
     * 
    **/
    data: XOR<TemperaturaUpdateManyMutationInput, TemperaturaUncheckedUpdateManyInput>
    /**
     * Filter which Temperaturas to update
     * 
    **/
    where?: TemperaturaWhereInput
  }


  /**
   * Temperatura upsert
   */
  export type TemperaturaUpsertArgs = {
    /**
     * Select specific fields to fetch from the Temperatura
     * 
    **/
    select?: TemperaturaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TemperaturaInclude | null
    /**
     * The filter to search for the Temperatura to update in case it exists.
     * 
    **/
    where: TemperaturaWhereUniqueInput
    /**
     * In case the Temperatura found by the `where` argument doesn't exist, create a new Temperatura with this data.
     * 
    **/
    create: XOR<TemperaturaCreateInput, TemperaturaUncheckedCreateInput>
    /**
     * In case the Temperatura was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<TemperaturaUpdateInput, TemperaturaUncheckedUpdateInput>
  }


  /**
   * Temperatura delete
   */
  export type TemperaturaDeleteArgs = {
    /**
     * Select specific fields to fetch from the Temperatura
     * 
    **/
    select?: TemperaturaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TemperaturaInclude | null
    /**
     * Filter which Temperatura to delete.
     * 
    **/
    where: TemperaturaWhereUniqueInput
  }


  /**
   * Temperatura deleteMany
   */
  export type TemperaturaDeleteManyArgs = {
    /**
     * Filter which Temperaturas to delete
     * 
    **/
    where?: TemperaturaWhereInput
  }


  /**
   * Temperatura without action
   */
  export type TemperaturaArgs = {
    /**
     * Select specific fields to fetch from the Temperatura
     * 
    **/
    select?: TemperaturaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TemperaturaInclude | null
  }



  /**
   * Model Pressao
   */


  export type AggregatePressao = {
    _count: PressaoCountAggregateOutputType | null
    _avg: PressaoAvgAggregateOutputType | null
    _sum: PressaoSumAggregateOutputType | null
    _min: PressaoMinAggregateOutputType | null
    _max: PressaoMaxAggregateOutputType | null
  }

  export type PressaoAvgAggregateOutputType = {
    id: number | null
    valor: number | null
    ordemGrandeza: number | null
    leituraId: number | null
  }

  export type PressaoSumAggregateOutputType = {
    id: number | null
    valor: number | null
    ordemGrandeza: number | null
    leituraId: number | null
  }

  export type PressaoMinAggregateOutputType = {
    id: number | null
    sensor: string | null
    valor: number | null
    unidade: string | null
    ordemGrandeza: number | null
    leituraId: number | null
  }

  export type PressaoMaxAggregateOutputType = {
    id: number | null
    sensor: string | null
    valor: number | null
    unidade: string | null
    ordemGrandeza: number | null
    leituraId: number | null
  }

  export type PressaoCountAggregateOutputType = {
    id: number
    sensor: number
    valor: number
    unidade: number
    ordemGrandeza: number
    leituraId: number
    _all: number
  }


  export type PressaoAvgAggregateInputType = {
    id?: true
    valor?: true
    ordemGrandeza?: true
    leituraId?: true
  }

  export type PressaoSumAggregateInputType = {
    id?: true
    valor?: true
    ordemGrandeza?: true
    leituraId?: true
  }

  export type PressaoMinAggregateInputType = {
    id?: true
    sensor?: true
    valor?: true
    unidade?: true
    ordemGrandeza?: true
    leituraId?: true
  }

  export type PressaoMaxAggregateInputType = {
    id?: true
    sensor?: true
    valor?: true
    unidade?: true
    ordemGrandeza?: true
    leituraId?: true
  }

  export type PressaoCountAggregateInputType = {
    id?: true
    sensor?: true
    valor?: true
    unidade?: true
    ordemGrandeza?: true
    leituraId?: true
    _all?: true
  }

  export type PressaoAggregateArgs = {
    /**
     * Filter which Pressao to aggregate.
     * 
    **/
    where?: PressaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pressaos to fetch.
     * 
    **/
    orderBy?: Enumerable<PressaoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PressaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pressaos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pressaos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pressaos
    **/
    _count?: true | PressaoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PressaoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PressaoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PressaoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PressaoMaxAggregateInputType
  }

  export type GetPressaoAggregateType<T extends PressaoAggregateArgs> = {
        [P in keyof T & keyof AggregatePressao]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePressao[P]>
      : GetScalarType<T[P], AggregatePressao[P]>
  }




  export type PressaoGroupByArgs = {
    where?: PressaoWhereInput
    orderBy?: Enumerable<PressaoOrderByWithAggregationInput>
    by: Array<PressaoScalarFieldEnum>
    having?: PressaoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PressaoCountAggregateInputType | true
    _avg?: PressaoAvgAggregateInputType
    _sum?: PressaoSumAggregateInputType
    _min?: PressaoMinAggregateInputType
    _max?: PressaoMaxAggregateInputType
  }


  export type PressaoGroupByOutputType = {
    id: number
    sensor: string
    valor: number
    unidade: string
    ordemGrandeza: number
    leituraId: number
    _count: PressaoCountAggregateOutputType | null
    _avg: PressaoAvgAggregateOutputType | null
    _sum: PressaoSumAggregateOutputType | null
    _min: PressaoMinAggregateOutputType | null
    _max: PressaoMaxAggregateOutputType | null
  }

  type GetPressaoGroupByPayload<T extends PressaoGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PressaoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PressaoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PressaoGroupByOutputType[P]>
            : GetScalarType<T[P], PressaoGroupByOutputType[P]>
        }
      >
    >


  export type PressaoSelect = {
    id?: boolean
    sensor?: boolean
    valor?: boolean
    unidade?: boolean
    ordemGrandeza?: boolean
    leituraId?: boolean
    leitura?: boolean | LeituraArgs
  }

  export type PressaoInclude = {
    leitura?: boolean | LeituraArgs
  }

  export type PressaoGetPayload<
    S extends boolean | null | undefined | PressaoArgs,
    U = keyof S
      > = S extends true
        ? Pressao
    : S extends undefined
    ? never
    : S extends PressaoArgs | PressaoFindManyArgs
    ?'include' extends U
    ? Pressao  & {
    [P in TrueKeys<S['include']>]:
        P extends 'leitura' ? LeituraGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'leitura' ? LeituraGetPayload<S['select'][P]> :  P extends keyof Pressao ? Pressao[P] : never
  } 
    : Pressao
  : Pressao


  type PressaoCountArgs = Merge<
    Omit<PressaoFindManyArgs, 'select' | 'include'> & {
      select?: PressaoCountAggregateInputType | true
    }
  >

  export interface PressaoDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Pressao that matches the filter.
     * @param {PressaoFindUniqueArgs} args - Arguments to find a Pressao
     * @example
     * // Get one Pressao
     * const pressao = await prisma.pressao.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PressaoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PressaoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Pressao'> extends True ? CheckSelect<T, Prisma__PressaoClient<Pressao>, Prisma__PressaoClient<PressaoGetPayload<T>>> : CheckSelect<T, Prisma__PressaoClient<Pressao | null >, Prisma__PressaoClient<PressaoGetPayload<T> | null >>

    /**
     * Find the first Pressao that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PressaoFindFirstArgs} args - Arguments to find a Pressao
     * @example
     * // Get one Pressao
     * const pressao = await prisma.pressao.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PressaoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PressaoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Pressao'> extends True ? CheckSelect<T, Prisma__PressaoClient<Pressao>, Prisma__PressaoClient<PressaoGetPayload<T>>> : CheckSelect<T, Prisma__PressaoClient<Pressao | null >, Prisma__PressaoClient<PressaoGetPayload<T> | null >>

    /**
     * Find zero or more Pressaos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PressaoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pressaos
     * const pressaos = await prisma.pressao.findMany()
     * 
     * // Get first 10 Pressaos
     * const pressaos = await prisma.pressao.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pressaoWithIdOnly = await prisma.pressao.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PressaoFindManyArgs>(
      args?: SelectSubset<T, PressaoFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Pressao>>, PrismaPromise<Array<PressaoGetPayload<T>>>>

    /**
     * Create a Pressao.
     * @param {PressaoCreateArgs} args - Arguments to create a Pressao.
     * @example
     * // Create one Pressao
     * const Pressao = await prisma.pressao.create({
     *   data: {
     *     // ... data to create a Pressao
     *   }
     * })
     * 
    **/
    create<T extends PressaoCreateArgs>(
      args: SelectSubset<T, PressaoCreateArgs>
    ): CheckSelect<T, Prisma__PressaoClient<Pressao>, Prisma__PressaoClient<PressaoGetPayload<T>>>

    /**
     * Delete a Pressao.
     * @param {PressaoDeleteArgs} args - Arguments to delete one Pressao.
     * @example
     * // Delete one Pressao
     * const Pressao = await prisma.pressao.delete({
     *   where: {
     *     // ... filter to delete one Pressao
     *   }
     * })
     * 
    **/
    delete<T extends PressaoDeleteArgs>(
      args: SelectSubset<T, PressaoDeleteArgs>
    ): CheckSelect<T, Prisma__PressaoClient<Pressao>, Prisma__PressaoClient<PressaoGetPayload<T>>>

    /**
     * Update one Pressao.
     * @param {PressaoUpdateArgs} args - Arguments to update one Pressao.
     * @example
     * // Update one Pressao
     * const pressao = await prisma.pressao.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PressaoUpdateArgs>(
      args: SelectSubset<T, PressaoUpdateArgs>
    ): CheckSelect<T, Prisma__PressaoClient<Pressao>, Prisma__PressaoClient<PressaoGetPayload<T>>>

    /**
     * Delete zero or more Pressaos.
     * @param {PressaoDeleteManyArgs} args - Arguments to filter Pressaos to delete.
     * @example
     * // Delete a few Pressaos
     * const { count } = await prisma.pressao.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PressaoDeleteManyArgs>(
      args?: SelectSubset<T, PressaoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pressaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PressaoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pressaos
     * const pressao = await prisma.pressao.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PressaoUpdateManyArgs>(
      args: SelectSubset<T, PressaoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Pressao.
     * @param {PressaoUpsertArgs} args - Arguments to update or create a Pressao.
     * @example
     * // Update or create a Pressao
     * const pressao = await prisma.pressao.upsert({
     *   create: {
     *     // ... data to create a Pressao
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pressao we want to update
     *   }
     * })
    **/
    upsert<T extends PressaoUpsertArgs>(
      args: SelectSubset<T, PressaoUpsertArgs>
    ): CheckSelect<T, Prisma__PressaoClient<Pressao>, Prisma__PressaoClient<PressaoGetPayload<T>>>

    /**
     * Count the number of Pressaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PressaoCountArgs} args - Arguments to filter Pressaos to count.
     * @example
     * // Count the number of Pressaos
     * const count = await prisma.pressao.count({
     *   where: {
     *     // ... the filter for the Pressaos we want to count
     *   }
     * })
    **/
    count<T extends PressaoCountArgs>(
      args?: Subset<T, PressaoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PressaoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pressao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PressaoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PressaoAggregateArgs>(args: Subset<T, PressaoAggregateArgs>): PrismaPromise<GetPressaoAggregateType<T>>

    /**
     * Group by Pressao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PressaoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PressaoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PressaoGroupByArgs['orderBy'] }
        : { orderBy?: PressaoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PressaoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPressaoGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Pressao.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PressaoClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    leitura<T extends LeituraArgs = {}>(args?: Subset<T, LeituraArgs>): CheckSelect<T, Prisma__LeituraClient<Leitura | null >, Prisma__LeituraClient<LeituraGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Pressao findUnique
   */
  export type PressaoFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Pressao
     * 
    **/
    select?: PressaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PressaoInclude | null
    /**
     * Throw an Error if a Pressao can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Pressao to fetch.
     * 
    **/
    where: PressaoWhereUniqueInput
  }


  /**
   * Pressao findFirst
   */
  export type PressaoFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Pressao
     * 
    **/
    select?: PressaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PressaoInclude | null
    /**
     * Throw an Error if a Pressao can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Pressao to fetch.
     * 
    **/
    where?: PressaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pressaos to fetch.
     * 
    **/
    orderBy?: Enumerable<PressaoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pressaos.
     * 
    **/
    cursor?: PressaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pressaos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pressaos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pressaos.
     * 
    **/
    distinct?: Enumerable<PressaoScalarFieldEnum>
  }


  /**
   * Pressao findMany
   */
  export type PressaoFindManyArgs = {
    /**
     * Select specific fields to fetch from the Pressao
     * 
    **/
    select?: PressaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PressaoInclude | null
    /**
     * Filter, which Pressaos to fetch.
     * 
    **/
    where?: PressaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pressaos to fetch.
     * 
    **/
    orderBy?: Enumerable<PressaoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pressaos.
     * 
    **/
    cursor?: PressaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pressaos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pressaos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PressaoScalarFieldEnum>
  }


  /**
   * Pressao create
   */
  export type PressaoCreateArgs = {
    /**
     * Select specific fields to fetch from the Pressao
     * 
    **/
    select?: PressaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PressaoInclude | null
    /**
     * The data needed to create a Pressao.
     * 
    **/
    data: XOR<PressaoCreateInput, PressaoUncheckedCreateInput>
  }


  /**
   * Pressao update
   */
  export type PressaoUpdateArgs = {
    /**
     * Select specific fields to fetch from the Pressao
     * 
    **/
    select?: PressaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PressaoInclude | null
    /**
     * The data needed to update a Pressao.
     * 
    **/
    data: XOR<PressaoUpdateInput, PressaoUncheckedUpdateInput>
    /**
     * Choose, which Pressao to update.
     * 
    **/
    where: PressaoWhereUniqueInput
  }


  /**
   * Pressao updateMany
   */
  export type PressaoUpdateManyArgs = {
    /**
     * The data used to update Pressaos.
     * 
    **/
    data: XOR<PressaoUpdateManyMutationInput, PressaoUncheckedUpdateManyInput>
    /**
     * Filter which Pressaos to update
     * 
    **/
    where?: PressaoWhereInput
  }


  /**
   * Pressao upsert
   */
  export type PressaoUpsertArgs = {
    /**
     * Select specific fields to fetch from the Pressao
     * 
    **/
    select?: PressaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PressaoInclude | null
    /**
     * The filter to search for the Pressao to update in case it exists.
     * 
    **/
    where: PressaoWhereUniqueInput
    /**
     * In case the Pressao found by the `where` argument doesn't exist, create a new Pressao with this data.
     * 
    **/
    create: XOR<PressaoCreateInput, PressaoUncheckedCreateInput>
    /**
     * In case the Pressao was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PressaoUpdateInput, PressaoUncheckedUpdateInput>
  }


  /**
   * Pressao delete
   */
  export type PressaoDeleteArgs = {
    /**
     * Select specific fields to fetch from the Pressao
     * 
    **/
    select?: PressaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PressaoInclude | null
    /**
     * Filter which Pressao to delete.
     * 
    **/
    where: PressaoWhereUniqueInput
  }


  /**
   * Pressao deleteMany
   */
  export type PressaoDeleteManyArgs = {
    /**
     * Filter which Pressaos to delete
     * 
    **/
    where?: PressaoWhereInput
  }


  /**
   * Pressao without action
   */
  export type PressaoArgs = {
    /**
     * Select specific fields to fetch from the Pressao
     * 
    **/
    select?: PressaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PressaoInclude | null
  }



  /**
   * Model Altitude
   */


  export type AggregateAltitude = {
    _count: AltitudeCountAggregateOutputType | null
    _avg: AltitudeAvgAggregateOutputType | null
    _sum: AltitudeSumAggregateOutputType | null
    _min: AltitudeMinAggregateOutputType | null
    _max: AltitudeMaxAggregateOutputType | null
  }

  export type AltitudeAvgAggregateOutputType = {
    id: number | null
    valor: number | null
    ordemGrandeza: number | null
    leituraId: number | null
  }

  export type AltitudeSumAggregateOutputType = {
    id: number | null
    valor: number | null
    ordemGrandeza: number | null
    leituraId: number | null
  }

  export type AltitudeMinAggregateOutputType = {
    id: number | null
    sensor: string | null
    valor: number | null
    unidade: string | null
    ordemGrandeza: number | null
    leituraId: number | null
  }

  export type AltitudeMaxAggregateOutputType = {
    id: number | null
    sensor: string | null
    valor: number | null
    unidade: string | null
    ordemGrandeza: number | null
    leituraId: number | null
  }

  export type AltitudeCountAggregateOutputType = {
    id: number
    sensor: number
    valor: number
    unidade: number
    ordemGrandeza: number
    leituraId: number
    _all: number
  }


  export type AltitudeAvgAggregateInputType = {
    id?: true
    valor?: true
    ordemGrandeza?: true
    leituraId?: true
  }

  export type AltitudeSumAggregateInputType = {
    id?: true
    valor?: true
    ordemGrandeza?: true
    leituraId?: true
  }

  export type AltitudeMinAggregateInputType = {
    id?: true
    sensor?: true
    valor?: true
    unidade?: true
    ordemGrandeza?: true
    leituraId?: true
  }

  export type AltitudeMaxAggregateInputType = {
    id?: true
    sensor?: true
    valor?: true
    unidade?: true
    ordemGrandeza?: true
    leituraId?: true
  }

  export type AltitudeCountAggregateInputType = {
    id?: true
    sensor?: true
    valor?: true
    unidade?: true
    ordemGrandeza?: true
    leituraId?: true
    _all?: true
  }

  export type AltitudeAggregateArgs = {
    /**
     * Filter which Altitude to aggregate.
     * 
    **/
    where?: AltitudeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Altitudes to fetch.
     * 
    **/
    orderBy?: Enumerable<AltitudeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: AltitudeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Altitudes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Altitudes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Altitudes
    **/
    _count?: true | AltitudeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AltitudeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AltitudeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AltitudeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AltitudeMaxAggregateInputType
  }

  export type GetAltitudeAggregateType<T extends AltitudeAggregateArgs> = {
        [P in keyof T & keyof AggregateAltitude]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAltitude[P]>
      : GetScalarType<T[P], AggregateAltitude[P]>
  }




  export type AltitudeGroupByArgs = {
    where?: AltitudeWhereInput
    orderBy?: Enumerable<AltitudeOrderByWithAggregationInput>
    by: Array<AltitudeScalarFieldEnum>
    having?: AltitudeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AltitudeCountAggregateInputType | true
    _avg?: AltitudeAvgAggregateInputType
    _sum?: AltitudeSumAggregateInputType
    _min?: AltitudeMinAggregateInputType
    _max?: AltitudeMaxAggregateInputType
  }


  export type AltitudeGroupByOutputType = {
    id: number
    sensor: string
    valor: number
    unidade: string
    ordemGrandeza: number
    leituraId: number
    _count: AltitudeCountAggregateOutputType | null
    _avg: AltitudeAvgAggregateOutputType | null
    _sum: AltitudeSumAggregateOutputType | null
    _min: AltitudeMinAggregateOutputType | null
    _max: AltitudeMaxAggregateOutputType | null
  }

  type GetAltitudeGroupByPayload<T extends AltitudeGroupByArgs> = PrismaPromise<
    Array<
      PickArray<AltitudeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AltitudeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AltitudeGroupByOutputType[P]>
            : GetScalarType<T[P], AltitudeGroupByOutputType[P]>
        }
      >
    >


  export type AltitudeSelect = {
    id?: boolean
    sensor?: boolean
    valor?: boolean
    unidade?: boolean
    ordemGrandeza?: boolean
    leituraId?: boolean
    leitura?: boolean | LeituraArgs
  }

  export type AltitudeInclude = {
    leitura?: boolean | LeituraArgs
  }

  export type AltitudeGetPayload<
    S extends boolean | null | undefined | AltitudeArgs,
    U = keyof S
      > = S extends true
        ? Altitude
    : S extends undefined
    ? never
    : S extends AltitudeArgs | AltitudeFindManyArgs
    ?'include' extends U
    ? Altitude  & {
    [P in TrueKeys<S['include']>]:
        P extends 'leitura' ? LeituraGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'leitura' ? LeituraGetPayload<S['select'][P]> :  P extends keyof Altitude ? Altitude[P] : never
  } 
    : Altitude
  : Altitude


  type AltitudeCountArgs = Merge<
    Omit<AltitudeFindManyArgs, 'select' | 'include'> & {
      select?: AltitudeCountAggregateInputType | true
    }
  >

  export interface AltitudeDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Altitude that matches the filter.
     * @param {AltitudeFindUniqueArgs} args - Arguments to find a Altitude
     * @example
     * // Get one Altitude
     * const altitude = await prisma.altitude.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AltitudeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, AltitudeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Altitude'> extends True ? CheckSelect<T, Prisma__AltitudeClient<Altitude>, Prisma__AltitudeClient<AltitudeGetPayload<T>>> : CheckSelect<T, Prisma__AltitudeClient<Altitude | null >, Prisma__AltitudeClient<AltitudeGetPayload<T> | null >>

    /**
     * Find the first Altitude that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AltitudeFindFirstArgs} args - Arguments to find a Altitude
     * @example
     * // Get one Altitude
     * const altitude = await prisma.altitude.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AltitudeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, AltitudeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Altitude'> extends True ? CheckSelect<T, Prisma__AltitudeClient<Altitude>, Prisma__AltitudeClient<AltitudeGetPayload<T>>> : CheckSelect<T, Prisma__AltitudeClient<Altitude | null >, Prisma__AltitudeClient<AltitudeGetPayload<T> | null >>

    /**
     * Find zero or more Altitudes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AltitudeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Altitudes
     * const altitudes = await prisma.altitude.findMany()
     * 
     * // Get first 10 Altitudes
     * const altitudes = await prisma.altitude.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const altitudeWithIdOnly = await prisma.altitude.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AltitudeFindManyArgs>(
      args?: SelectSubset<T, AltitudeFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Altitude>>, PrismaPromise<Array<AltitudeGetPayload<T>>>>

    /**
     * Create a Altitude.
     * @param {AltitudeCreateArgs} args - Arguments to create a Altitude.
     * @example
     * // Create one Altitude
     * const Altitude = await prisma.altitude.create({
     *   data: {
     *     // ... data to create a Altitude
     *   }
     * })
     * 
    **/
    create<T extends AltitudeCreateArgs>(
      args: SelectSubset<T, AltitudeCreateArgs>
    ): CheckSelect<T, Prisma__AltitudeClient<Altitude>, Prisma__AltitudeClient<AltitudeGetPayload<T>>>

    /**
     * Delete a Altitude.
     * @param {AltitudeDeleteArgs} args - Arguments to delete one Altitude.
     * @example
     * // Delete one Altitude
     * const Altitude = await prisma.altitude.delete({
     *   where: {
     *     // ... filter to delete one Altitude
     *   }
     * })
     * 
    **/
    delete<T extends AltitudeDeleteArgs>(
      args: SelectSubset<T, AltitudeDeleteArgs>
    ): CheckSelect<T, Prisma__AltitudeClient<Altitude>, Prisma__AltitudeClient<AltitudeGetPayload<T>>>

    /**
     * Update one Altitude.
     * @param {AltitudeUpdateArgs} args - Arguments to update one Altitude.
     * @example
     * // Update one Altitude
     * const altitude = await prisma.altitude.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AltitudeUpdateArgs>(
      args: SelectSubset<T, AltitudeUpdateArgs>
    ): CheckSelect<T, Prisma__AltitudeClient<Altitude>, Prisma__AltitudeClient<AltitudeGetPayload<T>>>

    /**
     * Delete zero or more Altitudes.
     * @param {AltitudeDeleteManyArgs} args - Arguments to filter Altitudes to delete.
     * @example
     * // Delete a few Altitudes
     * const { count } = await prisma.altitude.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AltitudeDeleteManyArgs>(
      args?: SelectSubset<T, AltitudeDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Altitudes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AltitudeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Altitudes
     * const altitude = await prisma.altitude.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AltitudeUpdateManyArgs>(
      args: SelectSubset<T, AltitudeUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Altitude.
     * @param {AltitudeUpsertArgs} args - Arguments to update or create a Altitude.
     * @example
     * // Update or create a Altitude
     * const altitude = await prisma.altitude.upsert({
     *   create: {
     *     // ... data to create a Altitude
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Altitude we want to update
     *   }
     * })
    **/
    upsert<T extends AltitudeUpsertArgs>(
      args: SelectSubset<T, AltitudeUpsertArgs>
    ): CheckSelect<T, Prisma__AltitudeClient<Altitude>, Prisma__AltitudeClient<AltitudeGetPayload<T>>>

    /**
     * Count the number of Altitudes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AltitudeCountArgs} args - Arguments to filter Altitudes to count.
     * @example
     * // Count the number of Altitudes
     * const count = await prisma.altitude.count({
     *   where: {
     *     // ... the filter for the Altitudes we want to count
     *   }
     * })
    **/
    count<T extends AltitudeCountArgs>(
      args?: Subset<T, AltitudeCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AltitudeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Altitude.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AltitudeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AltitudeAggregateArgs>(args: Subset<T, AltitudeAggregateArgs>): PrismaPromise<GetAltitudeAggregateType<T>>

    /**
     * Group by Altitude.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AltitudeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AltitudeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AltitudeGroupByArgs['orderBy'] }
        : { orderBy?: AltitudeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AltitudeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAltitudeGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Altitude.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__AltitudeClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    leitura<T extends LeituraArgs = {}>(args?: Subset<T, LeituraArgs>): CheckSelect<T, Prisma__LeituraClient<Leitura | null >, Prisma__LeituraClient<LeituraGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Altitude findUnique
   */
  export type AltitudeFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Altitude
     * 
    **/
    select?: AltitudeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AltitudeInclude | null
    /**
     * Throw an Error if a Altitude can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Altitude to fetch.
     * 
    **/
    where: AltitudeWhereUniqueInput
  }


  /**
   * Altitude findFirst
   */
  export type AltitudeFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Altitude
     * 
    **/
    select?: AltitudeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AltitudeInclude | null
    /**
     * Throw an Error if a Altitude can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Altitude to fetch.
     * 
    **/
    where?: AltitudeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Altitudes to fetch.
     * 
    **/
    orderBy?: Enumerable<AltitudeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Altitudes.
     * 
    **/
    cursor?: AltitudeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Altitudes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Altitudes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Altitudes.
     * 
    **/
    distinct?: Enumerable<AltitudeScalarFieldEnum>
  }


  /**
   * Altitude findMany
   */
  export type AltitudeFindManyArgs = {
    /**
     * Select specific fields to fetch from the Altitude
     * 
    **/
    select?: AltitudeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AltitudeInclude | null
    /**
     * Filter, which Altitudes to fetch.
     * 
    **/
    where?: AltitudeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Altitudes to fetch.
     * 
    **/
    orderBy?: Enumerable<AltitudeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Altitudes.
     * 
    **/
    cursor?: AltitudeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Altitudes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Altitudes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<AltitudeScalarFieldEnum>
  }


  /**
   * Altitude create
   */
  export type AltitudeCreateArgs = {
    /**
     * Select specific fields to fetch from the Altitude
     * 
    **/
    select?: AltitudeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AltitudeInclude | null
    /**
     * The data needed to create a Altitude.
     * 
    **/
    data: XOR<AltitudeCreateInput, AltitudeUncheckedCreateInput>
  }


  /**
   * Altitude update
   */
  export type AltitudeUpdateArgs = {
    /**
     * Select specific fields to fetch from the Altitude
     * 
    **/
    select?: AltitudeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AltitudeInclude | null
    /**
     * The data needed to update a Altitude.
     * 
    **/
    data: XOR<AltitudeUpdateInput, AltitudeUncheckedUpdateInput>
    /**
     * Choose, which Altitude to update.
     * 
    **/
    where: AltitudeWhereUniqueInput
  }


  /**
   * Altitude updateMany
   */
  export type AltitudeUpdateManyArgs = {
    /**
     * The data used to update Altitudes.
     * 
    **/
    data: XOR<AltitudeUpdateManyMutationInput, AltitudeUncheckedUpdateManyInput>
    /**
     * Filter which Altitudes to update
     * 
    **/
    where?: AltitudeWhereInput
  }


  /**
   * Altitude upsert
   */
  export type AltitudeUpsertArgs = {
    /**
     * Select specific fields to fetch from the Altitude
     * 
    **/
    select?: AltitudeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AltitudeInclude | null
    /**
     * The filter to search for the Altitude to update in case it exists.
     * 
    **/
    where: AltitudeWhereUniqueInput
    /**
     * In case the Altitude found by the `where` argument doesn't exist, create a new Altitude with this data.
     * 
    **/
    create: XOR<AltitudeCreateInput, AltitudeUncheckedCreateInput>
    /**
     * In case the Altitude was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<AltitudeUpdateInput, AltitudeUncheckedUpdateInput>
  }


  /**
   * Altitude delete
   */
  export type AltitudeDeleteArgs = {
    /**
     * Select specific fields to fetch from the Altitude
     * 
    **/
    select?: AltitudeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AltitudeInclude | null
    /**
     * Filter which Altitude to delete.
     * 
    **/
    where: AltitudeWhereUniqueInput
  }


  /**
   * Altitude deleteMany
   */
  export type AltitudeDeleteManyArgs = {
    /**
     * Filter which Altitudes to delete
     * 
    **/
    where?: AltitudeWhereInput
  }


  /**
   * Altitude without action
   */
  export type AltitudeArgs = {
    /**
     * Select specific fields to fetch from the Altitude
     * 
    **/
    select?: AltitudeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: AltitudeInclude | null
  }



  /**
   * Model VelocidadeVento
   */


  export type AggregateVelocidadeVento = {
    _count: VelocidadeVentoCountAggregateOutputType | null
    _avg: VelocidadeVentoAvgAggregateOutputType | null
    _sum: VelocidadeVentoSumAggregateOutputType | null
    _min: VelocidadeVentoMinAggregateOutputType | null
    _max: VelocidadeVentoMaxAggregateOutputType | null
  }

  export type VelocidadeVentoAvgAggregateOutputType = {
    id: number | null
    media: number | null
    maximo: number | null
    ordemGrandeza: number | null
    leituraId: number | null
  }

  export type VelocidadeVentoSumAggregateOutputType = {
    id: number | null
    media: number | null
    maximo: number | null
    ordemGrandeza: number | null
    leituraId: number | null
  }

  export type VelocidadeVentoMinAggregateOutputType = {
    id: number | null
    sensor: string | null
    media: number | null
    maximo: number | null
    unidade: string | null
    ordemGrandeza: number | null
    leituraId: number | null
  }

  export type VelocidadeVentoMaxAggregateOutputType = {
    id: number | null
    sensor: string | null
    media: number | null
    maximo: number | null
    unidade: string | null
    ordemGrandeza: number | null
    leituraId: number | null
  }

  export type VelocidadeVentoCountAggregateOutputType = {
    id: number
    sensor: number
    media: number
    maximo: number
    unidade: number
    ordemGrandeza: number
    leituraId: number
    _all: number
  }


  export type VelocidadeVentoAvgAggregateInputType = {
    id?: true
    media?: true
    maximo?: true
    ordemGrandeza?: true
    leituraId?: true
  }

  export type VelocidadeVentoSumAggregateInputType = {
    id?: true
    media?: true
    maximo?: true
    ordemGrandeza?: true
    leituraId?: true
  }

  export type VelocidadeVentoMinAggregateInputType = {
    id?: true
    sensor?: true
    media?: true
    maximo?: true
    unidade?: true
    ordemGrandeza?: true
    leituraId?: true
  }

  export type VelocidadeVentoMaxAggregateInputType = {
    id?: true
    sensor?: true
    media?: true
    maximo?: true
    unidade?: true
    ordemGrandeza?: true
    leituraId?: true
  }

  export type VelocidadeVentoCountAggregateInputType = {
    id?: true
    sensor?: true
    media?: true
    maximo?: true
    unidade?: true
    ordemGrandeza?: true
    leituraId?: true
    _all?: true
  }

  export type VelocidadeVentoAggregateArgs = {
    /**
     * Filter which VelocidadeVento to aggregate.
     * 
    **/
    where?: VelocidadeVentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VelocidadeVentos to fetch.
     * 
    **/
    orderBy?: Enumerable<VelocidadeVentoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: VelocidadeVentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VelocidadeVentos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VelocidadeVentos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VelocidadeVentos
    **/
    _count?: true | VelocidadeVentoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VelocidadeVentoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VelocidadeVentoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VelocidadeVentoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VelocidadeVentoMaxAggregateInputType
  }

  export type GetVelocidadeVentoAggregateType<T extends VelocidadeVentoAggregateArgs> = {
        [P in keyof T & keyof AggregateVelocidadeVento]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVelocidadeVento[P]>
      : GetScalarType<T[P], AggregateVelocidadeVento[P]>
  }




  export type VelocidadeVentoGroupByArgs = {
    where?: VelocidadeVentoWhereInput
    orderBy?: Enumerable<VelocidadeVentoOrderByWithAggregationInput>
    by: Array<VelocidadeVentoScalarFieldEnum>
    having?: VelocidadeVentoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VelocidadeVentoCountAggregateInputType | true
    _avg?: VelocidadeVentoAvgAggregateInputType
    _sum?: VelocidadeVentoSumAggregateInputType
    _min?: VelocidadeVentoMinAggregateInputType
    _max?: VelocidadeVentoMaxAggregateInputType
  }


  export type VelocidadeVentoGroupByOutputType = {
    id: number
    sensor: string
    media: number
    maximo: number
    unidade: string
    ordemGrandeza: number
    leituraId: number
    _count: VelocidadeVentoCountAggregateOutputType | null
    _avg: VelocidadeVentoAvgAggregateOutputType | null
    _sum: VelocidadeVentoSumAggregateOutputType | null
    _min: VelocidadeVentoMinAggregateOutputType | null
    _max: VelocidadeVentoMaxAggregateOutputType | null
  }

  type GetVelocidadeVentoGroupByPayload<T extends VelocidadeVentoGroupByArgs> = PrismaPromise<
    Array<
      PickArray<VelocidadeVentoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VelocidadeVentoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VelocidadeVentoGroupByOutputType[P]>
            : GetScalarType<T[P], VelocidadeVentoGroupByOutputType[P]>
        }
      >
    >


  export type VelocidadeVentoSelect = {
    id?: boolean
    sensor?: boolean
    media?: boolean
    maximo?: boolean
    unidade?: boolean
    ordemGrandeza?: boolean
    leituraId?: boolean
    leitura?: boolean | LeituraArgs
  }

  export type VelocidadeVentoInclude = {
    leitura?: boolean | LeituraArgs
  }

  export type VelocidadeVentoGetPayload<
    S extends boolean | null | undefined | VelocidadeVentoArgs,
    U = keyof S
      > = S extends true
        ? VelocidadeVento
    : S extends undefined
    ? never
    : S extends VelocidadeVentoArgs | VelocidadeVentoFindManyArgs
    ?'include' extends U
    ? VelocidadeVento  & {
    [P in TrueKeys<S['include']>]:
        P extends 'leitura' ? LeituraGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'leitura' ? LeituraGetPayload<S['select'][P]> :  P extends keyof VelocidadeVento ? VelocidadeVento[P] : never
  } 
    : VelocidadeVento
  : VelocidadeVento


  type VelocidadeVentoCountArgs = Merge<
    Omit<VelocidadeVentoFindManyArgs, 'select' | 'include'> & {
      select?: VelocidadeVentoCountAggregateInputType | true
    }
  >

  export interface VelocidadeVentoDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one VelocidadeVento that matches the filter.
     * @param {VelocidadeVentoFindUniqueArgs} args - Arguments to find a VelocidadeVento
     * @example
     * // Get one VelocidadeVento
     * const velocidadeVento = await prisma.velocidadeVento.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends VelocidadeVentoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, VelocidadeVentoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'VelocidadeVento'> extends True ? CheckSelect<T, Prisma__VelocidadeVentoClient<VelocidadeVento>, Prisma__VelocidadeVentoClient<VelocidadeVentoGetPayload<T>>> : CheckSelect<T, Prisma__VelocidadeVentoClient<VelocidadeVento | null >, Prisma__VelocidadeVentoClient<VelocidadeVentoGetPayload<T> | null >>

    /**
     * Find the first VelocidadeVento that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VelocidadeVentoFindFirstArgs} args - Arguments to find a VelocidadeVento
     * @example
     * // Get one VelocidadeVento
     * const velocidadeVento = await prisma.velocidadeVento.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends VelocidadeVentoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, VelocidadeVentoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'VelocidadeVento'> extends True ? CheckSelect<T, Prisma__VelocidadeVentoClient<VelocidadeVento>, Prisma__VelocidadeVentoClient<VelocidadeVentoGetPayload<T>>> : CheckSelect<T, Prisma__VelocidadeVentoClient<VelocidadeVento | null >, Prisma__VelocidadeVentoClient<VelocidadeVentoGetPayload<T> | null >>

    /**
     * Find zero or more VelocidadeVentos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VelocidadeVentoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VelocidadeVentos
     * const velocidadeVentos = await prisma.velocidadeVento.findMany()
     * 
     * // Get first 10 VelocidadeVentos
     * const velocidadeVentos = await prisma.velocidadeVento.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const velocidadeVentoWithIdOnly = await prisma.velocidadeVento.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends VelocidadeVentoFindManyArgs>(
      args?: SelectSubset<T, VelocidadeVentoFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<VelocidadeVento>>, PrismaPromise<Array<VelocidadeVentoGetPayload<T>>>>

    /**
     * Create a VelocidadeVento.
     * @param {VelocidadeVentoCreateArgs} args - Arguments to create a VelocidadeVento.
     * @example
     * // Create one VelocidadeVento
     * const VelocidadeVento = await prisma.velocidadeVento.create({
     *   data: {
     *     // ... data to create a VelocidadeVento
     *   }
     * })
     * 
    **/
    create<T extends VelocidadeVentoCreateArgs>(
      args: SelectSubset<T, VelocidadeVentoCreateArgs>
    ): CheckSelect<T, Prisma__VelocidadeVentoClient<VelocidadeVento>, Prisma__VelocidadeVentoClient<VelocidadeVentoGetPayload<T>>>

    /**
     * Delete a VelocidadeVento.
     * @param {VelocidadeVentoDeleteArgs} args - Arguments to delete one VelocidadeVento.
     * @example
     * // Delete one VelocidadeVento
     * const VelocidadeVento = await prisma.velocidadeVento.delete({
     *   where: {
     *     // ... filter to delete one VelocidadeVento
     *   }
     * })
     * 
    **/
    delete<T extends VelocidadeVentoDeleteArgs>(
      args: SelectSubset<T, VelocidadeVentoDeleteArgs>
    ): CheckSelect<T, Prisma__VelocidadeVentoClient<VelocidadeVento>, Prisma__VelocidadeVentoClient<VelocidadeVentoGetPayload<T>>>

    /**
     * Update one VelocidadeVento.
     * @param {VelocidadeVentoUpdateArgs} args - Arguments to update one VelocidadeVento.
     * @example
     * // Update one VelocidadeVento
     * const velocidadeVento = await prisma.velocidadeVento.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends VelocidadeVentoUpdateArgs>(
      args: SelectSubset<T, VelocidadeVentoUpdateArgs>
    ): CheckSelect<T, Prisma__VelocidadeVentoClient<VelocidadeVento>, Prisma__VelocidadeVentoClient<VelocidadeVentoGetPayload<T>>>

    /**
     * Delete zero or more VelocidadeVentos.
     * @param {VelocidadeVentoDeleteManyArgs} args - Arguments to filter VelocidadeVentos to delete.
     * @example
     * // Delete a few VelocidadeVentos
     * const { count } = await prisma.velocidadeVento.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends VelocidadeVentoDeleteManyArgs>(
      args?: SelectSubset<T, VelocidadeVentoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more VelocidadeVentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VelocidadeVentoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VelocidadeVentos
     * const velocidadeVento = await prisma.velocidadeVento.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends VelocidadeVentoUpdateManyArgs>(
      args: SelectSubset<T, VelocidadeVentoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one VelocidadeVento.
     * @param {VelocidadeVentoUpsertArgs} args - Arguments to update or create a VelocidadeVento.
     * @example
     * // Update or create a VelocidadeVento
     * const velocidadeVento = await prisma.velocidadeVento.upsert({
     *   create: {
     *     // ... data to create a VelocidadeVento
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VelocidadeVento we want to update
     *   }
     * })
    **/
    upsert<T extends VelocidadeVentoUpsertArgs>(
      args: SelectSubset<T, VelocidadeVentoUpsertArgs>
    ): CheckSelect<T, Prisma__VelocidadeVentoClient<VelocidadeVento>, Prisma__VelocidadeVentoClient<VelocidadeVentoGetPayload<T>>>

    /**
     * Count the number of VelocidadeVentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VelocidadeVentoCountArgs} args - Arguments to filter VelocidadeVentos to count.
     * @example
     * // Count the number of VelocidadeVentos
     * const count = await prisma.velocidadeVento.count({
     *   where: {
     *     // ... the filter for the VelocidadeVentos we want to count
     *   }
     * })
    **/
    count<T extends VelocidadeVentoCountArgs>(
      args?: Subset<T, VelocidadeVentoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VelocidadeVentoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VelocidadeVento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VelocidadeVentoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VelocidadeVentoAggregateArgs>(args: Subset<T, VelocidadeVentoAggregateArgs>): PrismaPromise<GetVelocidadeVentoAggregateType<T>>

    /**
     * Group by VelocidadeVento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VelocidadeVentoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VelocidadeVentoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VelocidadeVentoGroupByArgs['orderBy'] }
        : { orderBy?: VelocidadeVentoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VelocidadeVentoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVelocidadeVentoGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for VelocidadeVento.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__VelocidadeVentoClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    leitura<T extends LeituraArgs = {}>(args?: Subset<T, LeituraArgs>): CheckSelect<T, Prisma__LeituraClient<Leitura | null >, Prisma__LeituraClient<LeituraGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * VelocidadeVento findUnique
   */
  export type VelocidadeVentoFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the VelocidadeVento
     * 
    **/
    select?: VelocidadeVentoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VelocidadeVentoInclude | null
    /**
     * Throw an Error if a VelocidadeVento can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which VelocidadeVento to fetch.
     * 
    **/
    where: VelocidadeVentoWhereUniqueInput
  }


  /**
   * VelocidadeVento findFirst
   */
  export type VelocidadeVentoFindFirstArgs = {
    /**
     * Select specific fields to fetch from the VelocidadeVento
     * 
    **/
    select?: VelocidadeVentoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VelocidadeVentoInclude | null
    /**
     * Throw an Error if a VelocidadeVento can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which VelocidadeVento to fetch.
     * 
    **/
    where?: VelocidadeVentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VelocidadeVentos to fetch.
     * 
    **/
    orderBy?: Enumerable<VelocidadeVentoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VelocidadeVentos.
     * 
    **/
    cursor?: VelocidadeVentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VelocidadeVentos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VelocidadeVentos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VelocidadeVentos.
     * 
    **/
    distinct?: Enumerable<VelocidadeVentoScalarFieldEnum>
  }


  /**
   * VelocidadeVento findMany
   */
  export type VelocidadeVentoFindManyArgs = {
    /**
     * Select specific fields to fetch from the VelocidadeVento
     * 
    **/
    select?: VelocidadeVentoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VelocidadeVentoInclude | null
    /**
     * Filter, which VelocidadeVentos to fetch.
     * 
    **/
    where?: VelocidadeVentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VelocidadeVentos to fetch.
     * 
    **/
    orderBy?: Enumerable<VelocidadeVentoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VelocidadeVentos.
     * 
    **/
    cursor?: VelocidadeVentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VelocidadeVentos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VelocidadeVentos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<VelocidadeVentoScalarFieldEnum>
  }


  /**
   * VelocidadeVento create
   */
  export type VelocidadeVentoCreateArgs = {
    /**
     * Select specific fields to fetch from the VelocidadeVento
     * 
    **/
    select?: VelocidadeVentoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VelocidadeVentoInclude | null
    /**
     * The data needed to create a VelocidadeVento.
     * 
    **/
    data: XOR<VelocidadeVentoCreateInput, VelocidadeVentoUncheckedCreateInput>
  }


  /**
   * VelocidadeVento update
   */
  export type VelocidadeVentoUpdateArgs = {
    /**
     * Select specific fields to fetch from the VelocidadeVento
     * 
    **/
    select?: VelocidadeVentoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VelocidadeVentoInclude | null
    /**
     * The data needed to update a VelocidadeVento.
     * 
    **/
    data: XOR<VelocidadeVentoUpdateInput, VelocidadeVentoUncheckedUpdateInput>
    /**
     * Choose, which VelocidadeVento to update.
     * 
    **/
    where: VelocidadeVentoWhereUniqueInput
  }


  /**
   * VelocidadeVento updateMany
   */
  export type VelocidadeVentoUpdateManyArgs = {
    /**
     * The data used to update VelocidadeVentos.
     * 
    **/
    data: XOR<VelocidadeVentoUpdateManyMutationInput, VelocidadeVentoUncheckedUpdateManyInput>
    /**
     * Filter which VelocidadeVentos to update
     * 
    **/
    where?: VelocidadeVentoWhereInput
  }


  /**
   * VelocidadeVento upsert
   */
  export type VelocidadeVentoUpsertArgs = {
    /**
     * Select specific fields to fetch from the VelocidadeVento
     * 
    **/
    select?: VelocidadeVentoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VelocidadeVentoInclude | null
    /**
     * The filter to search for the VelocidadeVento to update in case it exists.
     * 
    **/
    where: VelocidadeVentoWhereUniqueInput
    /**
     * In case the VelocidadeVento found by the `where` argument doesn't exist, create a new VelocidadeVento with this data.
     * 
    **/
    create: XOR<VelocidadeVentoCreateInput, VelocidadeVentoUncheckedCreateInput>
    /**
     * In case the VelocidadeVento was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<VelocidadeVentoUpdateInput, VelocidadeVentoUncheckedUpdateInput>
  }


  /**
   * VelocidadeVento delete
   */
  export type VelocidadeVentoDeleteArgs = {
    /**
     * Select specific fields to fetch from the VelocidadeVento
     * 
    **/
    select?: VelocidadeVentoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VelocidadeVentoInclude | null
    /**
     * Filter which VelocidadeVento to delete.
     * 
    **/
    where: VelocidadeVentoWhereUniqueInput
  }


  /**
   * VelocidadeVento deleteMany
   */
  export type VelocidadeVentoDeleteManyArgs = {
    /**
     * Filter which VelocidadeVentos to delete
     * 
    **/
    where?: VelocidadeVentoWhereInput
  }


  /**
   * VelocidadeVento without action
   */
  export type VelocidadeVentoArgs = {
    /**
     * Select specific fields to fetch from the VelocidadeVento
     * 
    **/
    select?: VelocidadeVentoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VelocidadeVentoInclude | null
  }



  /**
   * Model DirecaoVento
   */


  export type AggregateDirecaoVento = {
    _count: DirecaoVentoCountAggregateOutputType | null
    _avg: DirecaoVentoAvgAggregateOutputType | null
    _sum: DirecaoVentoSumAggregateOutputType | null
    _min: DirecaoVentoMinAggregateOutputType | null
    _max: DirecaoVentoMaxAggregateOutputType | null
  }

  export type DirecaoVentoAvgAggregateOutputType = {
    id: number | null
    valor: number | null
    ordemGrandeza: number | null
    leituraId: number | null
  }

  export type DirecaoVentoSumAggregateOutputType = {
    id: number | null
    valor: number | null
    ordemGrandeza: number | null
    leituraId: number | null
  }

  export type DirecaoVentoMinAggregateOutputType = {
    id: number | null
    sensor: string | null
    valor: number | null
    unidade: string | null
    ordemGrandeza: number | null
    leituraId: number | null
  }

  export type DirecaoVentoMaxAggregateOutputType = {
    id: number | null
    sensor: string | null
    valor: number | null
    unidade: string | null
    ordemGrandeza: number | null
    leituraId: number | null
  }

  export type DirecaoVentoCountAggregateOutputType = {
    id: number
    sensor: number
    valor: number
    unidade: number
    ordemGrandeza: number
    leituraId: number
    _all: number
  }


  export type DirecaoVentoAvgAggregateInputType = {
    id?: true
    valor?: true
    ordemGrandeza?: true
    leituraId?: true
  }

  export type DirecaoVentoSumAggregateInputType = {
    id?: true
    valor?: true
    ordemGrandeza?: true
    leituraId?: true
  }

  export type DirecaoVentoMinAggregateInputType = {
    id?: true
    sensor?: true
    valor?: true
    unidade?: true
    ordemGrandeza?: true
    leituraId?: true
  }

  export type DirecaoVentoMaxAggregateInputType = {
    id?: true
    sensor?: true
    valor?: true
    unidade?: true
    ordemGrandeza?: true
    leituraId?: true
  }

  export type DirecaoVentoCountAggregateInputType = {
    id?: true
    sensor?: true
    valor?: true
    unidade?: true
    ordemGrandeza?: true
    leituraId?: true
    _all?: true
  }

  export type DirecaoVentoAggregateArgs = {
    /**
     * Filter which DirecaoVento to aggregate.
     * 
    **/
    where?: DirecaoVentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DirecaoVentos to fetch.
     * 
    **/
    orderBy?: Enumerable<DirecaoVentoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: DirecaoVentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DirecaoVentos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DirecaoVentos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DirecaoVentos
    **/
    _count?: true | DirecaoVentoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DirecaoVentoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DirecaoVentoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DirecaoVentoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DirecaoVentoMaxAggregateInputType
  }

  export type GetDirecaoVentoAggregateType<T extends DirecaoVentoAggregateArgs> = {
        [P in keyof T & keyof AggregateDirecaoVento]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDirecaoVento[P]>
      : GetScalarType<T[P], AggregateDirecaoVento[P]>
  }




  export type DirecaoVentoGroupByArgs = {
    where?: DirecaoVentoWhereInput
    orderBy?: Enumerable<DirecaoVentoOrderByWithAggregationInput>
    by: Array<DirecaoVentoScalarFieldEnum>
    having?: DirecaoVentoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DirecaoVentoCountAggregateInputType | true
    _avg?: DirecaoVentoAvgAggregateInputType
    _sum?: DirecaoVentoSumAggregateInputType
    _min?: DirecaoVentoMinAggregateInputType
    _max?: DirecaoVentoMaxAggregateInputType
  }


  export type DirecaoVentoGroupByOutputType = {
    id: number
    sensor: string
    valor: number
    unidade: string
    ordemGrandeza: number
    leituraId: number
    _count: DirecaoVentoCountAggregateOutputType | null
    _avg: DirecaoVentoAvgAggregateOutputType | null
    _sum: DirecaoVentoSumAggregateOutputType | null
    _min: DirecaoVentoMinAggregateOutputType | null
    _max: DirecaoVentoMaxAggregateOutputType | null
  }

  type GetDirecaoVentoGroupByPayload<T extends DirecaoVentoGroupByArgs> = PrismaPromise<
    Array<
      PickArray<DirecaoVentoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DirecaoVentoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DirecaoVentoGroupByOutputType[P]>
            : GetScalarType<T[P], DirecaoVentoGroupByOutputType[P]>
        }
      >
    >


  export type DirecaoVentoSelect = {
    id?: boolean
    sensor?: boolean
    valor?: boolean
    unidade?: boolean
    ordemGrandeza?: boolean
    leituraId?: boolean
    leitura?: boolean | LeituraArgs
  }

  export type DirecaoVentoInclude = {
    leitura?: boolean | LeituraArgs
  }

  export type DirecaoVentoGetPayload<
    S extends boolean | null | undefined | DirecaoVentoArgs,
    U = keyof S
      > = S extends true
        ? DirecaoVento
    : S extends undefined
    ? never
    : S extends DirecaoVentoArgs | DirecaoVentoFindManyArgs
    ?'include' extends U
    ? DirecaoVento  & {
    [P in TrueKeys<S['include']>]:
        P extends 'leitura' ? LeituraGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'leitura' ? LeituraGetPayload<S['select'][P]> :  P extends keyof DirecaoVento ? DirecaoVento[P] : never
  } 
    : DirecaoVento
  : DirecaoVento


  type DirecaoVentoCountArgs = Merge<
    Omit<DirecaoVentoFindManyArgs, 'select' | 'include'> & {
      select?: DirecaoVentoCountAggregateInputType | true
    }
  >

  export interface DirecaoVentoDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one DirecaoVento that matches the filter.
     * @param {DirecaoVentoFindUniqueArgs} args - Arguments to find a DirecaoVento
     * @example
     * // Get one DirecaoVento
     * const direcaoVento = await prisma.direcaoVento.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DirecaoVentoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, DirecaoVentoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'DirecaoVento'> extends True ? CheckSelect<T, Prisma__DirecaoVentoClient<DirecaoVento>, Prisma__DirecaoVentoClient<DirecaoVentoGetPayload<T>>> : CheckSelect<T, Prisma__DirecaoVentoClient<DirecaoVento | null >, Prisma__DirecaoVentoClient<DirecaoVentoGetPayload<T> | null >>

    /**
     * Find the first DirecaoVento that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirecaoVentoFindFirstArgs} args - Arguments to find a DirecaoVento
     * @example
     * // Get one DirecaoVento
     * const direcaoVento = await prisma.direcaoVento.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DirecaoVentoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, DirecaoVentoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'DirecaoVento'> extends True ? CheckSelect<T, Prisma__DirecaoVentoClient<DirecaoVento>, Prisma__DirecaoVentoClient<DirecaoVentoGetPayload<T>>> : CheckSelect<T, Prisma__DirecaoVentoClient<DirecaoVento | null >, Prisma__DirecaoVentoClient<DirecaoVentoGetPayload<T> | null >>

    /**
     * Find zero or more DirecaoVentos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirecaoVentoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DirecaoVentos
     * const direcaoVentos = await prisma.direcaoVento.findMany()
     * 
     * // Get first 10 DirecaoVentos
     * const direcaoVentos = await prisma.direcaoVento.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const direcaoVentoWithIdOnly = await prisma.direcaoVento.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DirecaoVentoFindManyArgs>(
      args?: SelectSubset<T, DirecaoVentoFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<DirecaoVento>>, PrismaPromise<Array<DirecaoVentoGetPayload<T>>>>

    /**
     * Create a DirecaoVento.
     * @param {DirecaoVentoCreateArgs} args - Arguments to create a DirecaoVento.
     * @example
     * // Create one DirecaoVento
     * const DirecaoVento = await prisma.direcaoVento.create({
     *   data: {
     *     // ... data to create a DirecaoVento
     *   }
     * })
     * 
    **/
    create<T extends DirecaoVentoCreateArgs>(
      args: SelectSubset<T, DirecaoVentoCreateArgs>
    ): CheckSelect<T, Prisma__DirecaoVentoClient<DirecaoVento>, Prisma__DirecaoVentoClient<DirecaoVentoGetPayload<T>>>

    /**
     * Delete a DirecaoVento.
     * @param {DirecaoVentoDeleteArgs} args - Arguments to delete one DirecaoVento.
     * @example
     * // Delete one DirecaoVento
     * const DirecaoVento = await prisma.direcaoVento.delete({
     *   where: {
     *     // ... filter to delete one DirecaoVento
     *   }
     * })
     * 
    **/
    delete<T extends DirecaoVentoDeleteArgs>(
      args: SelectSubset<T, DirecaoVentoDeleteArgs>
    ): CheckSelect<T, Prisma__DirecaoVentoClient<DirecaoVento>, Prisma__DirecaoVentoClient<DirecaoVentoGetPayload<T>>>

    /**
     * Update one DirecaoVento.
     * @param {DirecaoVentoUpdateArgs} args - Arguments to update one DirecaoVento.
     * @example
     * // Update one DirecaoVento
     * const direcaoVento = await prisma.direcaoVento.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DirecaoVentoUpdateArgs>(
      args: SelectSubset<T, DirecaoVentoUpdateArgs>
    ): CheckSelect<T, Prisma__DirecaoVentoClient<DirecaoVento>, Prisma__DirecaoVentoClient<DirecaoVentoGetPayload<T>>>

    /**
     * Delete zero or more DirecaoVentos.
     * @param {DirecaoVentoDeleteManyArgs} args - Arguments to filter DirecaoVentos to delete.
     * @example
     * // Delete a few DirecaoVentos
     * const { count } = await prisma.direcaoVento.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DirecaoVentoDeleteManyArgs>(
      args?: SelectSubset<T, DirecaoVentoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more DirecaoVentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirecaoVentoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DirecaoVentos
     * const direcaoVento = await prisma.direcaoVento.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DirecaoVentoUpdateManyArgs>(
      args: SelectSubset<T, DirecaoVentoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one DirecaoVento.
     * @param {DirecaoVentoUpsertArgs} args - Arguments to update or create a DirecaoVento.
     * @example
     * // Update or create a DirecaoVento
     * const direcaoVento = await prisma.direcaoVento.upsert({
     *   create: {
     *     // ... data to create a DirecaoVento
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DirecaoVento we want to update
     *   }
     * })
    **/
    upsert<T extends DirecaoVentoUpsertArgs>(
      args: SelectSubset<T, DirecaoVentoUpsertArgs>
    ): CheckSelect<T, Prisma__DirecaoVentoClient<DirecaoVento>, Prisma__DirecaoVentoClient<DirecaoVentoGetPayload<T>>>

    /**
     * Count the number of DirecaoVentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirecaoVentoCountArgs} args - Arguments to filter DirecaoVentos to count.
     * @example
     * // Count the number of DirecaoVentos
     * const count = await prisma.direcaoVento.count({
     *   where: {
     *     // ... the filter for the DirecaoVentos we want to count
     *   }
     * })
    **/
    count<T extends DirecaoVentoCountArgs>(
      args?: Subset<T, DirecaoVentoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DirecaoVentoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DirecaoVento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirecaoVentoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DirecaoVentoAggregateArgs>(args: Subset<T, DirecaoVentoAggregateArgs>): PrismaPromise<GetDirecaoVentoAggregateType<T>>

    /**
     * Group by DirecaoVento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirecaoVentoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DirecaoVentoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DirecaoVentoGroupByArgs['orderBy'] }
        : { orderBy?: DirecaoVentoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DirecaoVentoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDirecaoVentoGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for DirecaoVento.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__DirecaoVentoClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    leitura<T extends LeituraArgs = {}>(args?: Subset<T, LeituraArgs>): CheckSelect<T, Prisma__LeituraClient<Leitura | null >, Prisma__LeituraClient<LeituraGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * DirecaoVento findUnique
   */
  export type DirecaoVentoFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the DirecaoVento
     * 
    **/
    select?: DirecaoVentoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DirecaoVentoInclude | null
    /**
     * Throw an Error if a DirecaoVento can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which DirecaoVento to fetch.
     * 
    **/
    where: DirecaoVentoWhereUniqueInput
  }


  /**
   * DirecaoVento findFirst
   */
  export type DirecaoVentoFindFirstArgs = {
    /**
     * Select specific fields to fetch from the DirecaoVento
     * 
    **/
    select?: DirecaoVentoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DirecaoVentoInclude | null
    /**
     * Throw an Error if a DirecaoVento can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which DirecaoVento to fetch.
     * 
    **/
    where?: DirecaoVentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DirecaoVentos to fetch.
     * 
    **/
    orderBy?: Enumerable<DirecaoVentoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DirecaoVentos.
     * 
    **/
    cursor?: DirecaoVentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DirecaoVentos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DirecaoVentos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DirecaoVentos.
     * 
    **/
    distinct?: Enumerable<DirecaoVentoScalarFieldEnum>
  }


  /**
   * DirecaoVento findMany
   */
  export type DirecaoVentoFindManyArgs = {
    /**
     * Select specific fields to fetch from the DirecaoVento
     * 
    **/
    select?: DirecaoVentoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DirecaoVentoInclude | null
    /**
     * Filter, which DirecaoVentos to fetch.
     * 
    **/
    where?: DirecaoVentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DirecaoVentos to fetch.
     * 
    **/
    orderBy?: Enumerable<DirecaoVentoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DirecaoVentos.
     * 
    **/
    cursor?: DirecaoVentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DirecaoVentos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DirecaoVentos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<DirecaoVentoScalarFieldEnum>
  }


  /**
   * DirecaoVento create
   */
  export type DirecaoVentoCreateArgs = {
    /**
     * Select specific fields to fetch from the DirecaoVento
     * 
    **/
    select?: DirecaoVentoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DirecaoVentoInclude | null
    /**
     * The data needed to create a DirecaoVento.
     * 
    **/
    data: XOR<DirecaoVentoCreateInput, DirecaoVentoUncheckedCreateInput>
  }


  /**
   * DirecaoVento update
   */
  export type DirecaoVentoUpdateArgs = {
    /**
     * Select specific fields to fetch from the DirecaoVento
     * 
    **/
    select?: DirecaoVentoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DirecaoVentoInclude | null
    /**
     * The data needed to update a DirecaoVento.
     * 
    **/
    data: XOR<DirecaoVentoUpdateInput, DirecaoVentoUncheckedUpdateInput>
    /**
     * Choose, which DirecaoVento to update.
     * 
    **/
    where: DirecaoVentoWhereUniqueInput
  }


  /**
   * DirecaoVento updateMany
   */
  export type DirecaoVentoUpdateManyArgs = {
    /**
     * The data used to update DirecaoVentos.
     * 
    **/
    data: XOR<DirecaoVentoUpdateManyMutationInput, DirecaoVentoUncheckedUpdateManyInput>
    /**
     * Filter which DirecaoVentos to update
     * 
    **/
    where?: DirecaoVentoWhereInput
  }


  /**
   * DirecaoVento upsert
   */
  export type DirecaoVentoUpsertArgs = {
    /**
     * Select specific fields to fetch from the DirecaoVento
     * 
    **/
    select?: DirecaoVentoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DirecaoVentoInclude | null
    /**
     * The filter to search for the DirecaoVento to update in case it exists.
     * 
    **/
    where: DirecaoVentoWhereUniqueInput
    /**
     * In case the DirecaoVento found by the `where` argument doesn't exist, create a new DirecaoVento with this data.
     * 
    **/
    create: XOR<DirecaoVentoCreateInput, DirecaoVentoUncheckedCreateInput>
    /**
     * In case the DirecaoVento was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<DirecaoVentoUpdateInput, DirecaoVentoUncheckedUpdateInput>
  }


  /**
   * DirecaoVento delete
   */
  export type DirecaoVentoDeleteArgs = {
    /**
     * Select specific fields to fetch from the DirecaoVento
     * 
    **/
    select?: DirecaoVentoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DirecaoVentoInclude | null
    /**
     * Filter which DirecaoVento to delete.
     * 
    **/
    where: DirecaoVentoWhereUniqueInput
  }


  /**
   * DirecaoVento deleteMany
   */
  export type DirecaoVentoDeleteManyArgs = {
    /**
     * Filter which DirecaoVentos to delete
     * 
    **/
    where?: DirecaoVentoWhereInput
  }


  /**
   * DirecaoVento without action
   */
  export type DirecaoVentoArgs = {
    /**
     * Select specific fields to fetch from the DirecaoVento
     * 
    **/
    select?: DirecaoVentoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: DirecaoVentoInclude | null
  }



  /**
   * Model Precipitacao
   */


  export type AggregatePrecipitacao = {
    _count: PrecipitacaoCountAggregateOutputType | null
    _avg: PrecipitacaoAvgAggregateOutputType | null
    _sum: PrecipitacaoSumAggregateOutputType | null
    _min: PrecipitacaoMinAggregateOutputType | null
    _max: PrecipitacaoMaxAggregateOutputType | null
  }

  export type PrecipitacaoAvgAggregateOutputType = {
    id: number | null
    valor: number | null
    ordemGrandeza: number | null
    leituraId: number | null
  }

  export type PrecipitacaoSumAggregateOutputType = {
    id: number | null
    valor: number | null
    ordemGrandeza: number | null
    leituraId: number | null
  }

  export type PrecipitacaoMinAggregateOutputType = {
    id: number | null
    sensor: string | null
    valor: number | null
    unidade: string | null
    ordemGrandeza: number | null
    leituraId: number | null
  }

  export type PrecipitacaoMaxAggregateOutputType = {
    id: number | null
    sensor: string | null
    valor: number | null
    unidade: string | null
    ordemGrandeza: number | null
    leituraId: number | null
  }

  export type PrecipitacaoCountAggregateOutputType = {
    id: number
    sensor: number
    valor: number
    unidade: number
    ordemGrandeza: number
    leituraId: number
    _all: number
  }


  export type PrecipitacaoAvgAggregateInputType = {
    id?: true
    valor?: true
    ordemGrandeza?: true
    leituraId?: true
  }

  export type PrecipitacaoSumAggregateInputType = {
    id?: true
    valor?: true
    ordemGrandeza?: true
    leituraId?: true
  }

  export type PrecipitacaoMinAggregateInputType = {
    id?: true
    sensor?: true
    valor?: true
    unidade?: true
    ordemGrandeza?: true
    leituraId?: true
  }

  export type PrecipitacaoMaxAggregateInputType = {
    id?: true
    sensor?: true
    valor?: true
    unidade?: true
    ordemGrandeza?: true
    leituraId?: true
  }

  export type PrecipitacaoCountAggregateInputType = {
    id?: true
    sensor?: true
    valor?: true
    unidade?: true
    ordemGrandeza?: true
    leituraId?: true
    _all?: true
  }

  export type PrecipitacaoAggregateArgs = {
    /**
     * Filter which Precipitacao to aggregate.
     * 
    **/
    where?: PrecipitacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Precipitacaos to fetch.
     * 
    **/
    orderBy?: Enumerable<PrecipitacaoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PrecipitacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Precipitacaos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Precipitacaos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Precipitacaos
    **/
    _count?: true | PrecipitacaoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PrecipitacaoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PrecipitacaoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PrecipitacaoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PrecipitacaoMaxAggregateInputType
  }

  export type GetPrecipitacaoAggregateType<T extends PrecipitacaoAggregateArgs> = {
        [P in keyof T & keyof AggregatePrecipitacao]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrecipitacao[P]>
      : GetScalarType<T[P], AggregatePrecipitacao[P]>
  }




  export type PrecipitacaoGroupByArgs = {
    where?: PrecipitacaoWhereInput
    orderBy?: Enumerable<PrecipitacaoOrderByWithAggregationInput>
    by: Array<PrecipitacaoScalarFieldEnum>
    having?: PrecipitacaoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PrecipitacaoCountAggregateInputType | true
    _avg?: PrecipitacaoAvgAggregateInputType
    _sum?: PrecipitacaoSumAggregateInputType
    _min?: PrecipitacaoMinAggregateInputType
    _max?: PrecipitacaoMaxAggregateInputType
  }


  export type PrecipitacaoGroupByOutputType = {
    id: number
    sensor: string
    valor: number
    unidade: string
    ordemGrandeza: number
    leituraId: number
    _count: PrecipitacaoCountAggregateOutputType | null
    _avg: PrecipitacaoAvgAggregateOutputType | null
    _sum: PrecipitacaoSumAggregateOutputType | null
    _min: PrecipitacaoMinAggregateOutputType | null
    _max: PrecipitacaoMaxAggregateOutputType | null
  }

  type GetPrecipitacaoGroupByPayload<T extends PrecipitacaoGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PrecipitacaoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PrecipitacaoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PrecipitacaoGroupByOutputType[P]>
            : GetScalarType<T[P], PrecipitacaoGroupByOutputType[P]>
        }
      >
    >


  export type PrecipitacaoSelect = {
    id?: boolean
    sensor?: boolean
    valor?: boolean
    unidade?: boolean
    ordemGrandeza?: boolean
    leituraId?: boolean
    leitura?: boolean | LeituraArgs
  }

  export type PrecipitacaoInclude = {
    leitura?: boolean | LeituraArgs
  }

  export type PrecipitacaoGetPayload<
    S extends boolean | null | undefined | PrecipitacaoArgs,
    U = keyof S
      > = S extends true
        ? Precipitacao
    : S extends undefined
    ? never
    : S extends PrecipitacaoArgs | PrecipitacaoFindManyArgs
    ?'include' extends U
    ? Precipitacao  & {
    [P in TrueKeys<S['include']>]:
        P extends 'leitura' ? LeituraGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'leitura' ? LeituraGetPayload<S['select'][P]> :  P extends keyof Precipitacao ? Precipitacao[P] : never
  } 
    : Precipitacao
  : Precipitacao


  type PrecipitacaoCountArgs = Merge<
    Omit<PrecipitacaoFindManyArgs, 'select' | 'include'> & {
      select?: PrecipitacaoCountAggregateInputType | true
    }
  >

  export interface PrecipitacaoDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Precipitacao that matches the filter.
     * @param {PrecipitacaoFindUniqueArgs} args - Arguments to find a Precipitacao
     * @example
     * // Get one Precipitacao
     * const precipitacao = await prisma.precipitacao.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PrecipitacaoFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PrecipitacaoFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Precipitacao'> extends True ? CheckSelect<T, Prisma__PrecipitacaoClient<Precipitacao>, Prisma__PrecipitacaoClient<PrecipitacaoGetPayload<T>>> : CheckSelect<T, Prisma__PrecipitacaoClient<Precipitacao | null >, Prisma__PrecipitacaoClient<PrecipitacaoGetPayload<T> | null >>

    /**
     * Find the first Precipitacao that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrecipitacaoFindFirstArgs} args - Arguments to find a Precipitacao
     * @example
     * // Get one Precipitacao
     * const precipitacao = await prisma.precipitacao.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PrecipitacaoFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PrecipitacaoFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Precipitacao'> extends True ? CheckSelect<T, Prisma__PrecipitacaoClient<Precipitacao>, Prisma__PrecipitacaoClient<PrecipitacaoGetPayload<T>>> : CheckSelect<T, Prisma__PrecipitacaoClient<Precipitacao | null >, Prisma__PrecipitacaoClient<PrecipitacaoGetPayload<T> | null >>

    /**
     * Find zero or more Precipitacaos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrecipitacaoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Precipitacaos
     * const precipitacaos = await prisma.precipitacao.findMany()
     * 
     * // Get first 10 Precipitacaos
     * const precipitacaos = await prisma.precipitacao.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const precipitacaoWithIdOnly = await prisma.precipitacao.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PrecipitacaoFindManyArgs>(
      args?: SelectSubset<T, PrecipitacaoFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Precipitacao>>, PrismaPromise<Array<PrecipitacaoGetPayload<T>>>>

    /**
     * Create a Precipitacao.
     * @param {PrecipitacaoCreateArgs} args - Arguments to create a Precipitacao.
     * @example
     * // Create one Precipitacao
     * const Precipitacao = await prisma.precipitacao.create({
     *   data: {
     *     // ... data to create a Precipitacao
     *   }
     * })
     * 
    **/
    create<T extends PrecipitacaoCreateArgs>(
      args: SelectSubset<T, PrecipitacaoCreateArgs>
    ): CheckSelect<T, Prisma__PrecipitacaoClient<Precipitacao>, Prisma__PrecipitacaoClient<PrecipitacaoGetPayload<T>>>

    /**
     * Delete a Precipitacao.
     * @param {PrecipitacaoDeleteArgs} args - Arguments to delete one Precipitacao.
     * @example
     * // Delete one Precipitacao
     * const Precipitacao = await prisma.precipitacao.delete({
     *   where: {
     *     // ... filter to delete one Precipitacao
     *   }
     * })
     * 
    **/
    delete<T extends PrecipitacaoDeleteArgs>(
      args: SelectSubset<T, PrecipitacaoDeleteArgs>
    ): CheckSelect<T, Prisma__PrecipitacaoClient<Precipitacao>, Prisma__PrecipitacaoClient<PrecipitacaoGetPayload<T>>>

    /**
     * Update one Precipitacao.
     * @param {PrecipitacaoUpdateArgs} args - Arguments to update one Precipitacao.
     * @example
     * // Update one Precipitacao
     * const precipitacao = await prisma.precipitacao.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PrecipitacaoUpdateArgs>(
      args: SelectSubset<T, PrecipitacaoUpdateArgs>
    ): CheckSelect<T, Prisma__PrecipitacaoClient<Precipitacao>, Prisma__PrecipitacaoClient<PrecipitacaoGetPayload<T>>>

    /**
     * Delete zero or more Precipitacaos.
     * @param {PrecipitacaoDeleteManyArgs} args - Arguments to filter Precipitacaos to delete.
     * @example
     * // Delete a few Precipitacaos
     * const { count } = await prisma.precipitacao.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PrecipitacaoDeleteManyArgs>(
      args?: SelectSubset<T, PrecipitacaoDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Precipitacaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrecipitacaoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Precipitacaos
     * const precipitacao = await prisma.precipitacao.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PrecipitacaoUpdateManyArgs>(
      args: SelectSubset<T, PrecipitacaoUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Precipitacao.
     * @param {PrecipitacaoUpsertArgs} args - Arguments to update or create a Precipitacao.
     * @example
     * // Update or create a Precipitacao
     * const precipitacao = await prisma.precipitacao.upsert({
     *   create: {
     *     // ... data to create a Precipitacao
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Precipitacao we want to update
     *   }
     * })
    **/
    upsert<T extends PrecipitacaoUpsertArgs>(
      args: SelectSubset<T, PrecipitacaoUpsertArgs>
    ): CheckSelect<T, Prisma__PrecipitacaoClient<Precipitacao>, Prisma__PrecipitacaoClient<PrecipitacaoGetPayload<T>>>

    /**
     * Count the number of Precipitacaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrecipitacaoCountArgs} args - Arguments to filter Precipitacaos to count.
     * @example
     * // Count the number of Precipitacaos
     * const count = await prisma.precipitacao.count({
     *   where: {
     *     // ... the filter for the Precipitacaos we want to count
     *   }
     * })
    **/
    count<T extends PrecipitacaoCountArgs>(
      args?: Subset<T, PrecipitacaoCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PrecipitacaoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Precipitacao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrecipitacaoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PrecipitacaoAggregateArgs>(args: Subset<T, PrecipitacaoAggregateArgs>): PrismaPromise<GetPrecipitacaoAggregateType<T>>

    /**
     * Group by Precipitacao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrecipitacaoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PrecipitacaoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PrecipitacaoGroupByArgs['orderBy'] }
        : { orderBy?: PrecipitacaoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PrecipitacaoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrecipitacaoGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Precipitacao.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PrecipitacaoClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    leitura<T extends LeituraArgs = {}>(args?: Subset<T, LeituraArgs>): CheckSelect<T, Prisma__LeituraClient<Leitura | null >, Prisma__LeituraClient<LeituraGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Precipitacao findUnique
   */
  export type PrecipitacaoFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Precipitacao
     * 
    **/
    select?: PrecipitacaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PrecipitacaoInclude | null
    /**
     * Throw an Error if a Precipitacao can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Precipitacao to fetch.
     * 
    **/
    where: PrecipitacaoWhereUniqueInput
  }


  /**
   * Precipitacao findFirst
   */
  export type PrecipitacaoFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Precipitacao
     * 
    **/
    select?: PrecipitacaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PrecipitacaoInclude | null
    /**
     * Throw an Error if a Precipitacao can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Precipitacao to fetch.
     * 
    **/
    where?: PrecipitacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Precipitacaos to fetch.
     * 
    **/
    orderBy?: Enumerable<PrecipitacaoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Precipitacaos.
     * 
    **/
    cursor?: PrecipitacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Precipitacaos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Precipitacaos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Precipitacaos.
     * 
    **/
    distinct?: Enumerable<PrecipitacaoScalarFieldEnum>
  }


  /**
   * Precipitacao findMany
   */
  export type PrecipitacaoFindManyArgs = {
    /**
     * Select specific fields to fetch from the Precipitacao
     * 
    **/
    select?: PrecipitacaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PrecipitacaoInclude | null
    /**
     * Filter, which Precipitacaos to fetch.
     * 
    **/
    where?: PrecipitacaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Precipitacaos to fetch.
     * 
    **/
    orderBy?: Enumerable<PrecipitacaoOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Precipitacaos.
     * 
    **/
    cursor?: PrecipitacaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Precipitacaos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Precipitacaos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PrecipitacaoScalarFieldEnum>
  }


  /**
   * Precipitacao create
   */
  export type PrecipitacaoCreateArgs = {
    /**
     * Select specific fields to fetch from the Precipitacao
     * 
    **/
    select?: PrecipitacaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PrecipitacaoInclude | null
    /**
     * The data needed to create a Precipitacao.
     * 
    **/
    data: XOR<PrecipitacaoCreateInput, PrecipitacaoUncheckedCreateInput>
  }


  /**
   * Precipitacao update
   */
  export type PrecipitacaoUpdateArgs = {
    /**
     * Select specific fields to fetch from the Precipitacao
     * 
    **/
    select?: PrecipitacaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PrecipitacaoInclude | null
    /**
     * The data needed to update a Precipitacao.
     * 
    **/
    data: XOR<PrecipitacaoUpdateInput, PrecipitacaoUncheckedUpdateInput>
    /**
     * Choose, which Precipitacao to update.
     * 
    **/
    where: PrecipitacaoWhereUniqueInput
  }


  /**
   * Precipitacao updateMany
   */
  export type PrecipitacaoUpdateManyArgs = {
    /**
     * The data used to update Precipitacaos.
     * 
    **/
    data: XOR<PrecipitacaoUpdateManyMutationInput, PrecipitacaoUncheckedUpdateManyInput>
    /**
     * Filter which Precipitacaos to update
     * 
    **/
    where?: PrecipitacaoWhereInput
  }


  /**
   * Precipitacao upsert
   */
  export type PrecipitacaoUpsertArgs = {
    /**
     * Select specific fields to fetch from the Precipitacao
     * 
    **/
    select?: PrecipitacaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PrecipitacaoInclude | null
    /**
     * The filter to search for the Precipitacao to update in case it exists.
     * 
    **/
    where: PrecipitacaoWhereUniqueInput
    /**
     * In case the Precipitacao found by the `where` argument doesn't exist, create a new Precipitacao with this data.
     * 
    **/
    create: XOR<PrecipitacaoCreateInput, PrecipitacaoUncheckedCreateInput>
    /**
     * In case the Precipitacao was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PrecipitacaoUpdateInput, PrecipitacaoUncheckedUpdateInput>
  }


  /**
   * Precipitacao delete
   */
  export type PrecipitacaoDeleteArgs = {
    /**
     * Select specific fields to fetch from the Precipitacao
     * 
    **/
    select?: PrecipitacaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PrecipitacaoInclude | null
    /**
     * Filter which Precipitacao to delete.
     * 
    **/
    where: PrecipitacaoWhereUniqueInput
  }


  /**
   * Precipitacao deleteMany
   */
  export type PrecipitacaoDeleteManyArgs = {
    /**
     * Filter which Precipitacaos to delete
     * 
    **/
    where?: PrecipitacaoWhereInput
  }


  /**
   * Precipitacao without action
   */
  export type PrecipitacaoArgs = {
    /**
     * Select specific fields to fetch from the Precipitacao
     * 
    **/
    select?: PrecipitacaoSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PrecipitacaoInclude | null
  }



  /**
   * Model UmidadeSolo
   */


  export type AggregateUmidadeSolo = {
    _count: UmidadeSoloCountAggregateOutputType | null
    _avg: UmidadeSoloAvgAggregateOutputType | null
    _sum: UmidadeSoloSumAggregateOutputType | null
    _min: UmidadeSoloMinAggregateOutputType | null
    _max: UmidadeSoloMaxAggregateOutputType | null
  }

  export type UmidadeSoloAvgAggregateOutputType = {
    id: number | null
    valor: number | null
    ordemGrandeza: number | null
    leituraId: number | null
  }

  export type UmidadeSoloSumAggregateOutputType = {
    id: number | null
    valor: number | null
    ordemGrandeza: number | null
    leituraId: number | null
  }

  export type UmidadeSoloMinAggregateOutputType = {
    id: number | null
    sensor: string | null
    valor: number | null
    unidade: string | null
    ordemGrandeza: number | null
    leituraId: number | null
  }

  export type UmidadeSoloMaxAggregateOutputType = {
    id: number | null
    sensor: string | null
    valor: number | null
    unidade: string | null
    ordemGrandeza: number | null
    leituraId: number | null
  }

  export type UmidadeSoloCountAggregateOutputType = {
    id: number
    sensor: number
    valor: number
    unidade: number
    ordemGrandeza: number
    leituraId: number
    _all: number
  }


  export type UmidadeSoloAvgAggregateInputType = {
    id?: true
    valor?: true
    ordemGrandeza?: true
    leituraId?: true
  }

  export type UmidadeSoloSumAggregateInputType = {
    id?: true
    valor?: true
    ordemGrandeza?: true
    leituraId?: true
  }

  export type UmidadeSoloMinAggregateInputType = {
    id?: true
    sensor?: true
    valor?: true
    unidade?: true
    ordemGrandeza?: true
    leituraId?: true
  }

  export type UmidadeSoloMaxAggregateInputType = {
    id?: true
    sensor?: true
    valor?: true
    unidade?: true
    ordemGrandeza?: true
    leituraId?: true
  }

  export type UmidadeSoloCountAggregateInputType = {
    id?: true
    sensor?: true
    valor?: true
    unidade?: true
    ordemGrandeza?: true
    leituraId?: true
    _all?: true
  }

  export type UmidadeSoloAggregateArgs = {
    /**
     * Filter which UmidadeSolo to aggregate.
     * 
    **/
    where?: UmidadeSoloWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UmidadeSolos to fetch.
     * 
    **/
    orderBy?: Enumerable<UmidadeSoloOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UmidadeSoloWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UmidadeSolos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UmidadeSolos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UmidadeSolos
    **/
    _count?: true | UmidadeSoloCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UmidadeSoloAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UmidadeSoloSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UmidadeSoloMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UmidadeSoloMaxAggregateInputType
  }

  export type GetUmidadeSoloAggregateType<T extends UmidadeSoloAggregateArgs> = {
        [P in keyof T & keyof AggregateUmidadeSolo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUmidadeSolo[P]>
      : GetScalarType<T[P], AggregateUmidadeSolo[P]>
  }




  export type UmidadeSoloGroupByArgs = {
    where?: UmidadeSoloWhereInput
    orderBy?: Enumerable<UmidadeSoloOrderByWithAggregationInput>
    by: Array<UmidadeSoloScalarFieldEnum>
    having?: UmidadeSoloScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UmidadeSoloCountAggregateInputType | true
    _avg?: UmidadeSoloAvgAggregateInputType
    _sum?: UmidadeSoloSumAggregateInputType
    _min?: UmidadeSoloMinAggregateInputType
    _max?: UmidadeSoloMaxAggregateInputType
  }


  export type UmidadeSoloGroupByOutputType = {
    id: number
    sensor: string
    valor: number
    unidade: string
    ordemGrandeza: number
    leituraId: number
    _count: UmidadeSoloCountAggregateOutputType | null
    _avg: UmidadeSoloAvgAggregateOutputType | null
    _sum: UmidadeSoloSumAggregateOutputType | null
    _min: UmidadeSoloMinAggregateOutputType | null
    _max: UmidadeSoloMaxAggregateOutputType | null
  }

  type GetUmidadeSoloGroupByPayload<T extends UmidadeSoloGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UmidadeSoloGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UmidadeSoloGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UmidadeSoloGroupByOutputType[P]>
            : GetScalarType<T[P], UmidadeSoloGroupByOutputType[P]>
        }
      >
    >


  export type UmidadeSoloSelect = {
    id?: boolean
    sensor?: boolean
    valor?: boolean
    unidade?: boolean
    ordemGrandeza?: boolean
    leituraId?: boolean
    leitura?: boolean | LeituraArgs
  }

  export type UmidadeSoloInclude = {
    leitura?: boolean | LeituraArgs
  }

  export type UmidadeSoloGetPayload<
    S extends boolean | null | undefined | UmidadeSoloArgs,
    U = keyof S
      > = S extends true
        ? UmidadeSolo
    : S extends undefined
    ? never
    : S extends UmidadeSoloArgs | UmidadeSoloFindManyArgs
    ?'include' extends U
    ? UmidadeSolo  & {
    [P in TrueKeys<S['include']>]:
        P extends 'leitura' ? LeituraGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'leitura' ? LeituraGetPayload<S['select'][P]> :  P extends keyof UmidadeSolo ? UmidadeSolo[P] : never
  } 
    : UmidadeSolo
  : UmidadeSolo


  type UmidadeSoloCountArgs = Merge<
    Omit<UmidadeSoloFindManyArgs, 'select' | 'include'> & {
      select?: UmidadeSoloCountAggregateInputType | true
    }
  >

  export interface UmidadeSoloDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one UmidadeSolo that matches the filter.
     * @param {UmidadeSoloFindUniqueArgs} args - Arguments to find a UmidadeSolo
     * @example
     * // Get one UmidadeSolo
     * const umidadeSolo = await prisma.umidadeSolo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UmidadeSoloFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UmidadeSoloFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UmidadeSolo'> extends True ? CheckSelect<T, Prisma__UmidadeSoloClient<UmidadeSolo>, Prisma__UmidadeSoloClient<UmidadeSoloGetPayload<T>>> : CheckSelect<T, Prisma__UmidadeSoloClient<UmidadeSolo | null >, Prisma__UmidadeSoloClient<UmidadeSoloGetPayload<T> | null >>

    /**
     * Find the first UmidadeSolo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UmidadeSoloFindFirstArgs} args - Arguments to find a UmidadeSolo
     * @example
     * // Get one UmidadeSolo
     * const umidadeSolo = await prisma.umidadeSolo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UmidadeSoloFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UmidadeSoloFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UmidadeSolo'> extends True ? CheckSelect<T, Prisma__UmidadeSoloClient<UmidadeSolo>, Prisma__UmidadeSoloClient<UmidadeSoloGetPayload<T>>> : CheckSelect<T, Prisma__UmidadeSoloClient<UmidadeSolo | null >, Prisma__UmidadeSoloClient<UmidadeSoloGetPayload<T> | null >>

    /**
     * Find zero or more UmidadeSolos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UmidadeSoloFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UmidadeSolos
     * const umidadeSolos = await prisma.umidadeSolo.findMany()
     * 
     * // Get first 10 UmidadeSolos
     * const umidadeSolos = await prisma.umidadeSolo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const umidadeSoloWithIdOnly = await prisma.umidadeSolo.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UmidadeSoloFindManyArgs>(
      args?: SelectSubset<T, UmidadeSoloFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<UmidadeSolo>>, PrismaPromise<Array<UmidadeSoloGetPayload<T>>>>

    /**
     * Create a UmidadeSolo.
     * @param {UmidadeSoloCreateArgs} args - Arguments to create a UmidadeSolo.
     * @example
     * // Create one UmidadeSolo
     * const UmidadeSolo = await prisma.umidadeSolo.create({
     *   data: {
     *     // ... data to create a UmidadeSolo
     *   }
     * })
     * 
    **/
    create<T extends UmidadeSoloCreateArgs>(
      args: SelectSubset<T, UmidadeSoloCreateArgs>
    ): CheckSelect<T, Prisma__UmidadeSoloClient<UmidadeSolo>, Prisma__UmidadeSoloClient<UmidadeSoloGetPayload<T>>>

    /**
     * Delete a UmidadeSolo.
     * @param {UmidadeSoloDeleteArgs} args - Arguments to delete one UmidadeSolo.
     * @example
     * // Delete one UmidadeSolo
     * const UmidadeSolo = await prisma.umidadeSolo.delete({
     *   where: {
     *     // ... filter to delete one UmidadeSolo
     *   }
     * })
     * 
    **/
    delete<T extends UmidadeSoloDeleteArgs>(
      args: SelectSubset<T, UmidadeSoloDeleteArgs>
    ): CheckSelect<T, Prisma__UmidadeSoloClient<UmidadeSolo>, Prisma__UmidadeSoloClient<UmidadeSoloGetPayload<T>>>

    /**
     * Update one UmidadeSolo.
     * @param {UmidadeSoloUpdateArgs} args - Arguments to update one UmidadeSolo.
     * @example
     * // Update one UmidadeSolo
     * const umidadeSolo = await prisma.umidadeSolo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UmidadeSoloUpdateArgs>(
      args: SelectSubset<T, UmidadeSoloUpdateArgs>
    ): CheckSelect<T, Prisma__UmidadeSoloClient<UmidadeSolo>, Prisma__UmidadeSoloClient<UmidadeSoloGetPayload<T>>>

    /**
     * Delete zero or more UmidadeSolos.
     * @param {UmidadeSoloDeleteManyArgs} args - Arguments to filter UmidadeSolos to delete.
     * @example
     * // Delete a few UmidadeSolos
     * const { count } = await prisma.umidadeSolo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UmidadeSoloDeleteManyArgs>(
      args?: SelectSubset<T, UmidadeSoloDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more UmidadeSolos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UmidadeSoloUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UmidadeSolos
     * const umidadeSolo = await prisma.umidadeSolo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UmidadeSoloUpdateManyArgs>(
      args: SelectSubset<T, UmidadeSoloUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one UmidadeSolo.
     * @param {UmidadeSoloUpsertArgs} args - Arguments to update or create a UmidadeSolo.
     * @example
     * // Update or create a UmidadeSolo
     * const umidadeSolo = await prisma.umidadeSolo.upsert({
     *   create: {
     *     // ... data to create a UmidadeSolo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UmidadeSolo we want to update
     *   }
     * })
    **/
    upsert<T extends UmidadeSoloUpsertArgs>(
      args: SelectSubset<T, UmidadeSoloUpsertArgs>
    ): CheckSelect<T, Prisma__UmidadeSoloClient<UmidadeSolo>, Prisma__UmidadeSoloClient<UmidadeSoloGetPayload<T>>>

    /**
     * Count the number of UmidadeSolos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UmidadeSoloCountArgs} args - Arguments to filter UmidadeSolos to count.
     * @example
     * // Count the number of UmidadeSolos
     * const count = await prisma.umidadeSolo.count({
     *   where: {
     *     // ... the filter for the UmidadeSolos we want to count
     *   }
     * })
    **/
    count<T extends UmidadeSoloCountArgs>(
      args?: Subset<T, UmidadeSoloCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UmidadeSoloCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UmidadeSolo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UmidadeSoloAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UmidadeSoloAggregateArgs>(args: Subset<T, UmidadeSoloAggregateArgs>): PrismaPromise<GetUmidadeSoloAggregateType<T>>

    /**
     * Group by UmidadeSolo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UmidadeSoloGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UmidadeSoloGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UmidadeSoloGroupByArgs['orderBy'] }
        : { orderBy?: UmidadeSoloGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UmidadeSoloGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUmidadeSoloGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for UmidadeSolo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UmidadeSoloClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    leitura<T extends LeituraArgs = {}>(args?: Subset<T, LeituraArgs>): CheckSelect<T, Prisma__LeituraClient<Leitura | null >, Prisma__LeituraClient<LeituraGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * UmidadeSolo findUnique
   */
  export type UmidadeSoloFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the UmidadeSolo
     * 
    **/
    select?: UmidadeSoloSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UmidadeSoloInclude | null
    /**
     * Throw an Error if a UmidadeSolo can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UmidadeSolo to fetch.
     * 
    **/
    where: UmidadeSoloWhereUniqueInput
  }


  /**
   * UmidadeSolo findFirst
   */
  export type UmidadeSoloFindFirstArgs = {
    /**
     * Select specific fields to fetch from the UmidadeSolo
     * 
    **/
    select?: UmidadeSoloSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UmidadeSoloInclude | null
    /**
     * Throw an Error if a UmidadeSolo can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UmidadeSolo to fetch.
     * 
    **/
    where?: UmidadeSoloWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UmidadeSolos to fetch.
     * 
    **/
    orderBy?: Enumerable<UmidadeSoloOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UmidadeSolos.
     * 
    **/
    cursor?: UmidadeSoloWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UmidadeSolos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UmidadeSolos.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UmidadeSolos.
     * 
    **/
    distinct?: Enumerable<UmidadeSoloScalarFieldEnum>
  }


  /**
   * UmidadeSolo findMany
   */
  export type UmidadeSoloFindManyArgs = {
    /**
     * Select specific fields to fetch from the UmidadeSolo
     * 
    **/
    select?: UmidadeSoloSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UmidadeSoloInclude | null
    /**
     * Filter, which UmidadeSolos to fetch.
     * 
    **/
    where?: UmidadeSoloWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UmidadeSolos to fetch.
     * 
    **/
    orderBy?: Enumerable<UmidadeSoloOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UmidadeSolos.
     * 
    **/
    cursor?: UmidadeSoloWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UmidadeSolos from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UmidadeSolos.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UmidadeSoloScalarFieldEnum>
  }


  /**
   * UmidadeSolo create
   */
  export type UmidadeSoloCreateArgs = {
    /**
     * Select specific fields to fetch from the UmidadeSolo
     * 
    **/
    select?: UmidadeSoloSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UmidadeSoloInclude | null
    /**
     * The data needed to create a UmidadeSolo.
     * 
    **/
    data: XOR<UmidadeSoloCreateInput, UmidadeSoloUncheckedCreateInput>
  }


  /**
   * UmidadeSolo update
   */
  export type UmidadeSoloUpdateArgs = {
    /**
     * Select specific fields to fetch from the UmidadeSolo
     * 
    **/
    select?: UmidadeSoloSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UmidadeSoloInclude | null
    /**
     * The data needed to update a UmidadeSolo.
     * 
    **/
    data: XOR<UmidadeSoloUpdateInput, UmidadeSoloUncheckedUpdateInput>
    /**
     * Choose, which UmidadeSolo to update.
     * 
    **/
    where: UmidadeSoloWhereUniqueInput
  }


  /**
   * UmidadeSolo updateMany
   */
  export type UmidadeSoloUpdateManyArgs = {
    /**
     * The data used to update UmidadeSolos.
     * 
    **/
    data: XOR<UmidadeSoloUpdateManyMutationInput, UmidadeSoloUncheckedUpdateManyInput>
    /**
     * Filter which UmidadeSolos to update
     * 
    **/
    where?: UmidadeSoloWhereInput
  }


  /**
   * UmidadeSolo upsert
   */
  export type UmidadeSoloUpsertArgs = {
    /**
     * Select specific fields to fetch from the UmidadeSolo
     * 
    **/
    select?: UmidadeSoloSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UmidadeSoloInclude | null
    /**
     * The filter to search for the UmidadeSolo to update in case it exists.
     * 
    **/
    where: UmidadeSoloWhereUniqueInput
    /**
     * In case the UmidadeSolo found by the `where` argument doesn't exist, create a new UmidadeSolo with this data.
     * 
    **/
    create: XOR<UmidadeSoloCreateInput, UmidadeSoloUncheckedCreateInput>
    /**
     * In case the UmidadeSolo was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UmidadeSoloUpdateInput, UmidadeSoloUncheckedUpdateInput>
  }


  /**
   * UmidadeSolo delete
   */
  export type UmidadeSoloDeleteArgs = {
    /**
     * Select specific fields to fetch from the UmidadeSolo
     * 
    **/
    select?: UmidadeSoloSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UmidadeSoloInclude | null
    /**
     * Filter which UmidadeSolo to delete.
     * 
    **/
    where: UmidadeSoloWhereUniqueInput
  }


  /**
   * UmidadeSolo deleteMany
   */
  export type UmidadeSoloDeleteManyArgs = {
    /**
     * Filter which UmidadeSolos to delete
     * 
    **/
    where?: UmidadeSoloWhereInput
  }


  /**
   * UmidadeSolo without action
   */
  export type UmidadeSoloArgs = {
    /**
     * Select specific fields to fetch from the UmidadeSolo
     * 
    **/
    select?: UmidadeSoloSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UmidadeSoloInclude | null
  }



  /**
   * Model UmidadeRelativa
   */


  export type AggregateUmidadeRelativa = {
    _count: UmidadeRelativaCountAggregateOutputType | null
    _avg: UmidadeRelativaAvgAggregateOutputType | null
    _sum: UmidadeRelativaSumAggregateOutputType | null
    _min: UmidadeRelativaMinAggregateOutputType | null
    _max: UmidadeRelativaMaxAggregateOutputType | null
  }

  export type UmidadeRelativaAvgAggregateOutputType = {
    id: number | null
    valor: number | null
    ordemGrandeza: number | null
    leituraId: number | null
  }

  export type UmidadeRelativaSumAggregateOutputType = {
    id: number | null
    valor: number | null
    ordemGrandeza: number | null
    leituraId: number | null
  }

  export type UmidadeRelativaMinAggregateOutputType = {
    id: number | null
    sensor: string | null
    valor: number | null
    unidade: string | null
    ordemGrandeza: number | null
    leituraId: number | null
  }

  export type UmidadeRelativaMaxAggregateOutputType = {
    id: number | null
    sensor: string | null
    valor: number | null
    unidade: string | null
    ordemGrandeza: number | null
    leituraId: number | null
  }

  export type UmidadeRelativaCountAggregateOutputType = {
    id: number
    sensor: number
    valor: number
    unidade: number
    ordemGrandeza: number
    leituraId: number
    _all: number
  }


  export type UmidadeRelativaAvgAggregateInputType = {
    id?: true
    valor?: true
    ordemGrandeza?: true
    leituraId?: true
  }

  export type UmidadeRelativaSumAggregateInputType = {
    id?: true
    valor?: true
    ordemGrandeza?: true
    leituraId?: true
  }

  export type UmidadeRelativaMinAggregateInputType = {
    id?: true
    sensor?: true
    valor?: true
    unidade?: true
    ordemGrandeza?: true
    leituraId?: true
  }

  export type UmidadeRelativaMaxAggregateInputType = {
    id?: true
    sensor?: true
    valor?: true
    unidade?: true
    ordemGrandeza?: true
    leituraId?: true
  }

  export type UmidadeRelativaCountAggregateInputType = {
    id?: true
    sensor?: true
    valor?: true
    unidade?: true
    ordemGrandeza?: true
    leituraId?: true
    _all?: true
  }

  export type UmidadeRelativaAggregateArgs = {
    /**
     * Filter which UmidadeRelativa to aggregate.
     * 
    **/
    where?: UmidadeRelativaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UmidadeRelativas to fetch.
     * 
    **/
    orderBy?: Enumerable<UmidadeRelativaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UmidadeRelativaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UmidadeRelativas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UmidadeRelativas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UmidadeRelativas
    **/
    _count?: true | UmidadeRelativaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UmidadeRelativaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UmidadeRelativaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UmidadeRelativaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UmidadeRelativaMaxAggregateInputType
  }

  export type GetUmidadeRelativaAggregateType<T extends UmidadeRelativaAggregateArgs> = {
        [P in keyof T & keyof AggregateUmidadeRelativa]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUmidadeRelativa[P]>
      : GetScalarType<T[P], AggregateUmidadeRelativa[P]>
  }




  export type UmidadeRelativaGroupByArgs = {
    where?: UmidadeRelativaWhereInput
    orderBy?: Enumerable<UmidadeRelativaOrderByWithAggregationInput>
    by: Array<UmidadeRelativaScalarFieldEnum>
    having?: UmidadeRelativaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UmidadeRelativaCountAggregateInputType | true
    _avg?: UmidadeRelativaAvgAggregateInputType
    _sum?: UmidadeRelativaSumAggregateInputType
    _min?: UmidadeRelativaMinAggregateInputType
    _max?: UmidadeRelativaMaxAggregateInputType
  }


  export type UmidadeRelativaGroupByOutputType = {
    id: number
    sensor: string
    valor: number
    unidade: string
    ordemGrandeza: number
    leituraId: number
    _count: UmidadeRelativaCountAggregateOutputType | null
    _avg: UmidadeRelativaAvgAggregateOutputType | null
    _sum: UmidadeRelativaSumAggregateOutputType | null
    _min: UmidadeRelativaMinAggregateOutputType | null
    _max: UmidadeRelativaMaxAggregateOutputType | null
  }

  type GetUmidadeRelativaGroupByPayload<T extends UmidadeRelativaGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UmidadeRelativaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UmidadeRelativaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UmidadeRelativaGroupByOutputType[P]>
            : GetScalarType<T[P], UmidadeRelativaGroupByOutputType[P]>
        }
      >
    >


  export type UmidadeRelativaSelect = {
    id?: boolean
    sensor?: boolean
    valor?: boolean
    unidade?: boolean
    ordemGrandeza?: boolean
    leituraId?: boolean
    leitura?: boolean | LeituraArgs
  }

  export type UmidadeRelativaInclude = {
    leitura?: boolean | LeituraArgs
  }

  export type UmidadeRelativaGetPayload<
    S extends boolean | null | undefined | UmidadeRelativaArgs,
    U = keyof S
      > = S extends true
        ? UmidadeRelativa
    : S extends undefined
    ? never
    : S extends UmidadeRelativaArgs | UmidadeRelativaFindManyArgs
    ?'include' extends U
    ? UmidadeRelativa  & {
    [P in TrueKeys<S['include']>]:
        P extends 'leitura' ? LeituraGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'leitura' ? LeituraGetPayload<S['select'][P]> :  P extends keyof UmidadeRelativa ? UmidadeRelativa[P] : never
  } 
    : UmidadeRelativa
  : UmidadeRelativa


  type UmidadeRelativaCountArgs = Merge<
    Omit<UmidadeRelativaFindManyArgs, 'select' | 'include'> & {
      select?: UmidadeRelativaCountAggregateInputType | true
    }
  >

  export interface UmidadeRelativaDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one UmidadeRelativa that matches the filter.
     * @param {UmidadeRelativaFindUniqueArgs} args - Arguments to find a UmidadeRelativa
     * @example
     * // Get one UmidadeRelativa
     * const umidadeRelativa = await prisma.umidadeRelativa.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UmidadeRelativaFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UmidadeRelativaFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'UmidadeRelativa'> extends True ? CheckSelect<T, Prisma__UmidadeRelativaClient<UmidadeRelativa>, Prisma__UmidadeRelativaClient<UmidadeRelativaGetPayload<T>>> : CheckSelect<T, Prisma__UmidadeRelativaClient<UmidadeRelativa | null >, Prisma__UmidadeRelativaClient<UmidadeRelativaGetPayload<T> | null >>

    /**
     * Find the first UmidadeRelativa that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UmidadeRelativaFindFirstArgs} args - Arguments to find a UmidadeRelativa
     * @example
     * // Get one UmidadeRelativa
     * const umidadeRelativa = await prisma.umidadeRelativa.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UmidadeRelativaFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UmidadeRelativaFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'UmidadeRelativa'> extends True ? CheckSelect<T, Prisma__UmidadeRelativaClient<UmidadeRelativa>, Prisma__UmidadeRelativaClient<UmidadeRelativaGetPayload<T>>> : CheckSelect<T, Prisma__UmidadeRelativaClient<UmidadeRelativa | null >, Prisma__UmidadeRelativaClient<UmidadeRelativaGetPayload<T> | null >>

    /**
     * Find zero or more UmidadeRelativas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UmidadeRelativaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UmidadeRelativas
     * const umidadeRelativas = await prisma.umidadeRelativa.findMany()
     * 
     * // Get first 10 UmidadeRelativas
     * const umidadeRelativas = await prisma.umidadeRelativa.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const umidadeRelativaWithIdOnly = await prisma.umidadeRelativa.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UmidadeRelativaFindManyArgs>(
      args?: SelectSubset<T, UmidadeRelativaFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<UmidadeRelativa>>, PrismaPromise<Array<UmidadeRelativaGetPayload<T>>>>

    /**
     * Create a UmidadeRelativa.
     * @param {UmidadeRelativaCreateArgs} args - Arguments to create a UmidadeRelativa.
     * @example
     * // Create one UmidadeRelativa
     * const UmidadeRelativa = await prisma.umidadeRelativa.create({
     *   data: {
     *     // ... data to create a UmidadeRelativa
     *   }
     * })
     * 
    **/
    create<T extends UmidadeRelativaCreateArgs>(
      args: SelectSubset<T, UmidadeRelativaCreateArgs>
    ): CheckSelect<T, Prisma__UmidadeRelativaClient<UmidadeRelativa>, Prisma__UmidadeRelativaClient<UmidadeRelativaGetPayload<T>>>

    /**
     * Delete a UmidadeRelativa.
     * @param {UmidadeRelativaDeleteArgs} args - Arguments to delete one UmidadeRelativa.
     * @example
     * // Delete one UmidadeRelativa
     * const UmidadeRelativa = await prisma.umidadeRelativa.delete({
     *   where: {
     *     // ... filter to delete one UmidadeRelativa
     *   }
     * })
     * 
    **/
    delete<T extends UmidadeRelativaDeleteArgs>(
      args: SelectSubset<T, UmidadeRelativaDeleteArgs>
    ): CheckSelect<T, Prisma__UmidadeRelativaClient<UmidadeRelativa>, Prisma__UmidadeRelativaClient<UmidadeRelativaGetPayload<T>>>

    /**
     * Update one UmidadeRelativa.
     * @param {UmidadeRelativaUpdateArgs} args - Arguments to update one UmidadeRelativa.
     * @example
     * // Update one UmidadeRelativa
     * const umidadeRelativa = await prisma.umidadeRelativa.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UmidadeRelativaUpdateArgs>(
      args: SelectSubset<T, UmidadeRelativaUpdateArgs>
    ): CheckSelect<T, Prisma__UmidadeRelativaClient<UmidadeRelativa>, Prisma__UmidadeRelativaClient<UmidadeRelativaGetPayload<T>>>

    /**
     * Delete zero or more UmidadeRelativas.
     * @param {UmidadeRelativaDeleteManyArgs} args - Arguments to filter UmidadeRelativas to delete.
     * @example
     * // Delete a few UmidadeRelativas
     * const { count } = await prisma.umidadeRelativa.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UmidadeRelativaDeleteManyArgs>(
      args?: SelectSubset<T, UmidadeRelativaDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more UmidadeRelativas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UmidadeRelativaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UmidadeRelativas
     * const umidadeRelativa = await prisma.umidadeRelativa.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UmidadeRelativaUpdateManyArgs>(
      args: SelectSubset<T, UmidadeRelativaUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one UmidadeRelativa.
     * @param {UmidadeRelativaUpsertArgs} args - Arguments to update or create a UmidadeRelativa.
     * @example
     * // Update or create a UmidadeRelativa
     * const umidadeRelativa = await prisma.umidadeRelativa.upsert({
     *   create: {
     *     // ... data to create a UmidadeRelativa
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UmidadeRelativa we want to update
     *   }
     * })
    **/
    upsert<T extends UmidadeRelativaUpsertArgs>(
      args: SelectSubset<T, UmidadeRelativaUpsertArgs>
    ): CheckSelect<T, Prisma__UmidadeRelativaClient<UmidadeRelativa>, Prisma__UmidadeRelativaClient<UmidadeRelativaGetPayload<T>>>

    /**
     * Count the number of UmidadeRelativas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UmidadeRelativaCountArgs} args - Arguments to filter UmidadeRelativas to count.
     * @example
     * // Count the number of UmidadeRelativas
     * const count = await prisma.umidadeRelativa.count({
     *   where: {
     *     // ... the filter for the UmidadeRelativas we want to count
     *   }
     * })
    **/
    count<T extends UmidadeRelativaCountArgs>(
      args?: Subset<T, UmidadeRelativaCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UmidadeRelativaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UmidadeRelativa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UmidadeRelativaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UmidadeRelativaAggregateArgs>(args: Subset<T, UmidadeRelativaAggregateArgs>): PrismaPromise<GetUmidadeRelativaAggregateType<T>>

    /**
     * Group by UmidadeRelativa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UmidadeRelativaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UmidadeRelativaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UmidadeRelativaGroupByArgs['orderBy'] }
        : { orderBy?: UmidadeRelativaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UmidadeRelativaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUmidadeRelativaGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for UmidadeRelativa.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UmidadeRelativaClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    leitura<T extends LeituraArgs = {}>(args?: Subset<T, LeituraArgs>): CheckSelect<T, Prisma__LeituraClient<Leitura | null >, Prisma__LeituraClient<LeituraGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * UmidadeRelativa findUnique
   */
  export type UmidadeRelativaFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the UmidadeRelativa
     * 
    **/
    select?: UmidadeRelativaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UmidadeRelativaInclude | null
    /**
     * Throw an Error if a UmidadeRelativa can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UmidadeRelativa to fetch.
     * 
    **/
    where: UmidadeRelativaWhereUniqueInput
  }


  /**
   * UmidadeRelativa findFirst
   */
  export type UmidadeRelativaFindFirstArgs = {
    /**
     * Select specific fields to fetch from the UmidadeRelativa
     * 
    **/
    select?: UmidadeRelativaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UmidadeRelativaInclude | null
    /**
     * Throw an Error if a UmidadeRelativa can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which UmidadeRelativa to fetch.
     * 
    **/
    where?: UmidadeRelativaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UmidadeRelativas to fetch.
     * 
    **/
    orderBy?: Enumerable<UmidadeRelativaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UmidadeRelativas.
     * 
    **/
    cursor?: UmidadeRelativaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UmidadeRelativas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UmidadeRelativas.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UmidadeRelativas.
     * 
    **/
    distinct?: Enumerable<UmidadeRelativaScalarFieldEnum>
  }


  /**
   * UmidadeRelativa findMany
   */
  export type UmidadeRelativaFindManyArgs = {
    /**
     * Select specific fields to fetch from the UmidadeRelativa
     * 
    **/
    select?: UmidadeRelativaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UmidadeRelativaInclude | null
    /**
     * Filter, which UmidadeRelativas to fetch.
     * 
    **/
    where?: UmidadeRelativaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UmidadeRelativas to fetch.
     * 
    **/
    orderBy?: Enumerable<UmidadeRelativaOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UmidadeRelativas.
     * 
    **/
    cursor?: UmidadeRelativaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UmidadeRelativas from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UmidadeRelativas.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UmidadeRelativaScalarFieldEnum>
  }


  /**
   * UmidadeRelativa create
   */
  export type UmidadeRelativaCreateArgs = {
    /**
     * Select specific fields to fetch from the UmidadeRelativa
     * 
    **/
    select?: UmidadeRelativaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UmidadeRelativaInclude | null
    /**
     * The data needed to create a UmidadeRelativa.
     * 
    **/
    data: XOR<UmidadeRelativaCreateInput, UmidadeRelativaUncheckedCreateInput>
  }


  /**
   * UmidadeRelativa update
   */
  export type UmidadeRelativaUpdateArgs = {
    /**
     * Select specific fields to fetch from the UmidadeRelativa
     * 
    **/
    select?: UmidadeRelativaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UmidadeRelativaInclude | null
    /**
     * The data needed to update a UmidadeRelativa.
     * 
    **/
    data: XOR<UmidadeRelativaUpdateInput, UmidadeRelativaUncheckedUpdateInput>
    /**
     * Choose, which UmidadeRelativa to update.
     * 
    **/
    where: UmidadeRelativaWhereUniqueInput
  }


  /**
   * UmidadeRelativa updateMany
   */
  export type UmidadeRelativaUpdateManyArgs = {
    /**
     * The data used to update UmidadeRelativas.
     * 
    **/
    data: XOR<UmidadeRelativaUpdateManyMutationInput, UmidadeRelativaUncheckedUpdateManyInput>
    /**
     * Filter which UmidadeRelativas to update
     * 
    **/
    where?: UmidadeRelativaWhereInput
  }


  /**
   * UmidadeRelativa upsert
   */
  export type UmidadeRelativaUpsertArgs = {
    /**
     * Select specific fields to fetch from the UmidadeRelativa
     * 
    **/
    select?: UmidadeRelativaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UmidadeRelativaInclude | null
    /**
     * The filter to search for the UmidadeRelativa to update in case it exists.
     * 
    **/
    where: UmidadeRelativaWhereUniqueInput
    /**
     * In case the UmidadeRelativa found by the `where` argument doesn't exist, create a new UmidadeRelativa with this data.
     * 
    **/
    create: XOR<UmidadeRelativaCreateInput, UmidadeRelativaUncheckedCreateInput>
    /**
     * In case the UmidadeRelativa was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UmidadeRelativaUpdateInput, UmidadeRelativaUncheckedUpdateInput>
  }


  /**
   * UmidadeRelativa delete
   */
  export type UmidadeRelativaDeleteArgs = {
    /**
     * Select specific fields to fetch from the UmidadeRelativa
     * 
    **/
    select?: UmidadeRelativaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UmidadeRelativaInclude | null
    /**
     * Filter which UmidadeRelativa to delete.
     * 
    **/
    where: UmidadeRelativaWhereUniqueInput
  }


  /**
   * UmidadeRelativa deleteMany
   */
  export type UmidadeRelativaDeleteManyArgs = {
    /**
     * Filter which UmidadeRelativas to delete
     * 
    **/
    where?: UmidadeRelativaWhereInput
  }


  /**
   * UmidadeRelativa without action
   */
  export type UmidadeRelativaArgs = {
    /**
     * Select specific fields to fetch from the UmidadeRelativa
     * 
    **/
    select?: UmidadeRelativaSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UmidadeRelativaInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const LeituraScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt'
  };

  export type LeituraScalarFieldEnum = (typeof LeituraScalarFieldEnum)[keyof typeof LeituraScalarFieldEnum]


  export const TemperaturaScalarFieldEnum: {
    id: 'id',
    sensor: 'sensor',
    valor: 'valor',
    unidade: 'unidade',
    ordemGrandeza: 'ordemGrandeza',
    leituraId: 'leituraId'
  };

  export type TemperaturaScalarFieldEnum = (typeof TemperaturaScalarFieldEnum)[keyof typeof TemperaturaScalarFieldEnum]


  export const PressaoScalarFieldEnum: {
    id: 'id',
    sensor: 'sensor',
    valor: 'valor',
    unidade: 'unidade',
    ordemGrandeza: 'ordemGrandeza',
    leituraId: 'leituraId'
  };

  export type PressaoScalarFieldEnum = (typeof PressaoScalarFieldEnum)[keyof typeof PressaoScalarFieldEnum]


  export const AltitudeScalarFieldEnum: {
    id: 'id',
    sensor: 'sensor',
    valor: 'valor',
    unidade: 'unidade',
    ordemGrandeza: 'ordemGrandeza',
    leituraId: 'leituraId'
  };

  export type AltitudeScalarFieldEnum = (typeof AltitudeScalarFieldEnum)[keyof typeof AltitudeScalarFieldEnum]


  export const VelocidadeVentoScalarFieldEnum: {
    id: 'id',
    sensor: 'sensor',
    media: 'media',
    maximo: 'maximo',
    unidade: 'unidade',
    ordemGrandeza: 'ordemGrandeza',
    leituraId: 'leituraId'
  };

  export type VelocidadeVentoScalarFieldEnum = (typeof VelocidadeVentoScalarFieldEnum)[keyof typeof VelocidadeVentoScalarFieldEnum]


  export const DirecaoVentoScalarFieldEnum: {
    id: 'id',
    sensor: 'sensor',
    valor: 'valor',
    unidade: 'unidade',
    ordemGrandeza: 'ordemGrandeza',
    leituraId: 'leituraId'
  };

  export type DirecaoVentoScalarFieldEnum = (typeof DirecaoVentoScalarFieldEnum)[keyof typeof DirecaoVentoScalarFieldEnum]


  export const PrecipitacaoScalarFieldEnum: {
    id: 'id',
    sensor: 'sensor',
    valor: 'valor',
    unidade: 'unidade',
    ordemGrandeza: 'ordemGrandeza',
    leituraId: 'leituraId'
  };

  export type PrecipitacaoScalarFieldEnum = (typeof PrecipitacaoScalarFieldEnum)[keyof typeof PrecipitacaoScalarFieldEnum]


  export const UmidadeSoloScalarFieldEnum: {
    id: 'id',
    sensor: 'sensor',
    valor: 'valor',
    unidade: 'unidade',
    ordemGrandeza: 'ordemGrandeza',
    leituraId: 'leituraId'
  };

  export type UmidadeSoloScalarFieldEnum = (typeof UmidadeSoloScalarFieldEnum)[keyof typeof UmidadeSoloScalarFieldEnum]


  export const UmidadeRelativaScalarFieldEnum: {
    id: 'id',
    sensor: 'sensor',
    valor: 'valor',
    unidade: 'unidade',
    ordemGrandeza: 'ordemGrandeza',
    leituraId: 'leituraId'
  };

  export type UmidadeRelativaScalarFieldEnum = (typeof UmidadeRelativaScalarFieldEnum)[keyof typeof UmidadeRelativaScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  /**
   * Deep Input Types
   */


  export type LeituraWhereInput = {
    AND?: Enumerable<LeituraWhereInput>
    OR?: Enumerable<LeituraWhereInput>
    NOT?: Enumerable<LeituraWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    Temperatura?: TemperaturaListRelationFilter
    Pressao?: PressaoListRelationFilter
    Altitude?: AltitudeListRelationFilter
    VelocidadeVento?: VelocidadeVentoListRelationFilter
    DirecaoVento?: DirecaoVentoListRelationFilter
    Precipitacao?: PrecipitacaoListRelationFilter
    UmidadeSolo?: UmidadeSoloListRelationFilter
    UmidadeRelativa?: UmidadeRelativaListRelationFilter
  }

  export type LeituraOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    Temperatura?: TemperaturaOrderByRelationAggregateInput
    Pressao?: PressaoOrderByRelationAggregateInput
    Altitude?: AltitudeOrderByRelationAggregateInput
    VelocidadeVento?: VelocidadeVentoOrderByRelationAggregateInput
    DirecaoVento?: DirecaoVentoOrderByRelationAggregateInput
    Precipitacao?: PrecipitacaoOrderByRelationAggregateInput
    UmidadeSolo?: UmidadeSoloOrderByRelationAggregateInput
    UmidadeRelativa?: UmidadeRelativaOrderByRelationAggregateInput
  }

  export type LeituraWhereUniqueInput = {
    id?: number
  }

  export type LeituraOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    _count?: LeituraCountOrderByAggregateInput
    _avg?: LeituraAvgOrderByAggregateInput
    _max?: LeituraMaxOrderByAggregateInput
    _min?: LeituraMinOrderByAggregateInput
    _sum?: LeituraSumOrderByAggregateInput
  }

  export type LeituraScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LeituraScalarWhereWithAggregatesInput>
    OR?: Enumerable<LeituraScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LeituraScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type TemperaturaWhereInput = {
    AND?: Enumerable<TemperaturaWhereInput>
    OR?: Enumerable<TemperaturaWhereInput>
    NOT?: Enumerable<TemperaturaWhereInput>
    id?: IntFilter | number
    sensor?: StringFilter | string
    valor?: IntFilter | number
    unidade?: StringFilter | string
    ordemGrandeza?: IntFilter | number
    leituraId?: IntFilter | number
    leitura?: XOR<LeituraRelationFilter, LeituraWhereInput>
  }

  export type TemperaturaOrderByWithRelationInput = {
    id?: SortOrder
    sensor?: SortOrder
    valor?: SortOrder
    unidade?: SortOrder
    ordemGrandeza?: SortOrder
    leituraId?: SortOrder
    leitura?: LeituraOrderByWithRelationInput
  }

  export type TemperaturaWhereUniqueInput = {
    id?: number
  }

  export type TemperaturaOrderByWithAggregationInput = {
    id?: SortOrder
    sensor?: SortOrder
    valor?: SortOrder
    unidade?: SortOrder
    ordemGrandeza?: SortOrder
    leituraId?: SortOrder
    _count?: TemperaturaCountOrderByAggregateInput
    _avg?: TemperaturaAvgOrderByAggregateInput
    _max?: TemperaturaMaxOrderByAggregateInput
    _min?: TemperaturaMinOrderByAggregateInput
    _sum?: TemperaturaSumOrderByAggregateInput
  }

  export type TemperaturaScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TemperaturaScalarWhereWithAggregatesInput>
    OR?: Enumerable<TemperaturaScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TemperaturaScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    sensor?: StringWithAggregatesFilter | string
    valor?: IntWithAggregatesFilter | number
    unidade?: StringWithAggregatesFilter | string
    ordemGrandeza?: IntWithAggregatesFilter | number
    leituraId?: IntWithAggregatesFilter | number
  }

  export type PressaoWhereInput = {
    AND?: Enumerable<PressaoWhereInput>
    OR?: Enumerable<PressaoWhereInput>
    NOT?: Enumerable<PressaoWhereInput>
    id?: IntFilter | number
    sensor?: StringFilter | string
    valor?: IntFilter | number
    unidade?: StringFilter | string
    ordemGrandeza?: IntFilter | number
    leituraId?: IntFilter | number
    leitura?: XOR<LeituraRelationFilter, LeituraWhereInput>
  }

  export type PressaoOrderByWithRelationInput = {
    id?: SortOrder
    sensor?: SortOrder
    valor?: SortOrder
    unidade?: SortOrder
    ordemGrandeza?: SortOrder
    leituraId?: SortOrder
    leitura?: LeituraOrderByWithRelationInput
  }

  export type PressaoWhereUniqueInput = {
    id?: number
  }

  export type PressaoOrderByWithAggregationInput = {
    id?: SortOrder
    sensor?: SortOrder
    valor?: SortOrder
    unidade?: SortOrder
    ordemGrandeza?: SortOrder
    leituraId?: SortOrder
    _count?: PressaoCountOrderByAggregateInput
    _avg?: PressaoAvgOrderByAggregateInput
    _max?: PressaoMaxOrderByAggregateInput
    _min?: PressaoMinOrderByAggregateInput
    _sum?: PressaoSumOrderByAggregateInput
  }

  export type PressaoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PressaoScalarWhereWithAggregatesInput>
    OR?: Enumerable<PressaoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PressaoScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    sensor?: StringWithAggregatesFilter | string
    valor?: IntWithAggregatesFilter | number
    unidade?: StringWithAggregatesFilter | string
    ordemGrandeza?: IntWithAggregatesFilter | number
    leituraId?: IntWithAggregatesFilter | number
  }

  export type AltitudeWhereInput = {
    AND?: Enumerable<AltitudeWhereInput>
    OR?: Enumerable<AltitudeWhereInput>
    NOT?: Enumerable<AltitudeWhereInput>
    id?: IntFilter | number
    sensor?: StringFilter | string
    valor?: IntFilter | number
    unidade?: StringFilter | string
    ordemGrandeza?: IntFilter | number
    leituraId?: IntFilter | number
    leitura?: XOR<LeituraRelationFilter, LeituraWhereInput>
  }

  export type AltitudeOrderByWithRelationInput = {
    id?: SortOrder
    sensor?: SortOrder
    valor?: SortOrder
    unidade?: SortOrder
    ordemGrandeza?: SortOrder
    leituraId?: SortOrder
    leitura?: LeituraOrderByWithRelationInput
  }

  export type AltitudeWhereUniqueInput = {
    id?: number
  }

  export type AltitudeOrderByWithAggregationInput = {
    id?: SortOrder
    sensor?: SortOrder
    valor?: SortOrder
    unidade?: SortOrder
    ordemGrandeza?: SortOrder
    leituraId?: SortOrder
    _count?: AltitudeCountOrderByAggregateInput
    _avg?: AltitudeAvgOrderByAggregateInput
    _max?: AltitudeMaxOrderByAggregateInput
    _min?: AltitudeMinOrderByAggregateInput
    _sum?: AltitudeSumOrderByAggregateInput
  }

  export type AltitudeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<AltitudeScalarWhereWithAggregatesInput>
    OR?: Enumerable<AltitudeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<AltitudeScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    sensor?: StringWithAggregatesFilter | string
    valor?: IntWithAggregatesFilter | number
    unidade?: StringWithAggregatesFilter | string
    ordemGrandeza?: IntWithAggregatesFilter | number
    leituraId?: IntWithAggregatesFilter | number
  }

  export type VelocidadeVentoWhereInput = {
    AND?: Enumerable<VelocidadeVentoWhereInput>
    OR?: Enumerable<VelocidadeVentoWhereInput>
    NOT?: Enumerable<VelocidadeVentoWhereInput>
    id?: IntFilter | number
    sensor?: StringFilter | string
    media?: IntFilter | number
    maximo?: IntFilter | number
    unidade?: StringFilter | string
    ordemGrandeza?: IntFilter | number
    leituraId?: IntFilter | number
    leitura?: XOR<LeituraRelationFilter, LeituraWhereInput>
  }

  export type VelocidadeVentoOrderByWithRelationInput = {
    id?: SortOrder
    sensor?: SortOrder
    media?: SortOrder
    maximo?: SortOrder
    unidade?: SortOrder
    ordemGrandeza?: SortOrder
    leituraId?: SortOrder
    leitura?: LeituraOrderByWithRelationInput
  }

  export type VelocidadeVentoWhereUniqueInput = {
    id?: number
  }

  export type VelocidadeVentoOrderByWithAggregationInput = {
    id?: SortOrder
    sensor?: SortOrder
    media?: SortOrder
    maximo?: SortOrder
    unidade?: SortOrder
    ordemGrandeza?: SortOrder
    leituraId?: SortOrder
    _count?: VelocidadeVentoCountOrderByAggregateInput
    _avg?: VelocidadeVentoAvgOrderByAggregateInput
    _max?: VelocidadeVentoMaxOrderByAggregateInput
    _min?: VelocidadeVentoMinOrderByAggregateInput
    _sum?: VelocidadeVentoSumOrderByAggregateInput
  }

  export type VelocidadeVentoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<VelocidadeVentoScalarWhereWithAggregatesInput>
    OR?: Enumerable<VelocidadeVentoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<VelocidadeVentoScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    sensor?: StringWithAggregatesFilter | string
    media?: IntWithAggregatesFilter | number
    maximo?: IntWithAggregatesFilter | number
    unidade?: StringWithAggregatesFilter | string
    ordemGrandeza?: IntWithAggregatesFilter | number
    leituraId?: IntWithAggregatesFilter | number
  }

  export type DirecaoVentoWhereInput = {
    AND?: Enumerable<DirecaoVentoWhereInput>
    OR?: Enumerable<DirecaoVentoWhereInput>
    NOT?: Enumerable<DirecaoVentoWhereInput>
    id?: IntFilter | number
    sensor?: StringFilter | string
    valor?: IntFilter | number
    unidade?: StringFilter | string
    ordemGrandeza?: IntFilter | number
    leituraId?: IntFilter | number
    leitura?: XOR<LeituraRelationFilter, LeituraWhereInput>
  }

  export type DirecaoVentoOrderByWithRelationInput = {
    id?: SortOrder
    sensor?: SortOrder
    valor?: SortOrder
    unidade?: SortOrder
    ordemGrandeza?: SortOrder
    leituraId?: SortOrder
    leitura?: LeituraOrderByWithRelationInput
  }

  export type DirecaoVentoWhereUniqueInput = {
    id?: number
  }

  export type DirecaoVentoOrderByWithAggregationInput = {
    id?: SortOrder
    sensor?: SortOrder
    valor?: SortOrder
    unidade?: SortOrder
    ordemGrandeza?: SortOrder
    leituraId?: SortOrder
    _count?: DirecaoVentoCountOrderByAggregateInput
    _avg?: DirecaoVentoAvgOrderByAggregateInput
    _max?: DirecaoVentoMaxOrderByAggregateInput
    _min?: DirecaoVentoMinOrderByAggregateInput
    _sum?: DirecaoVentoSumOrderByAggregateInput
  }

  export type DirecaoVentoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<DirecaoVentoScalarWhereWithAggregatesInput>
    OR?: Enumerable<DirecaoVentoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<DirecaoVentoScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    sensor?: StringWithAggregatesFilter | string
    valor?: IntWithAggregatesFilter | number
    unidade?: StringWithAggregatesFilter | string
    ordemGrandeza?: IntWithAggregatesFilter | number
    leituraId?: IntWithAggregatesFilter | number
  }

  export type PrecipitacaoWhereInput = {
    AND?: Enumerable<PrecipitacaoWhereInput>
    OR?: Enumerable<PrecipitacaoWhereInput>
    NOT?: Enumerable<PrecipitacaoWhereInput>
    id?: IntFilter | number
    sensor?: StringFilter | string
    valor?: IntFilter | number
    unidade?: StringFilter | string
    ordemGrandeza?: IntFilter | number
    leituraId?: IntFilter | number
    leitura?: XOR<LeituraRelationFilter, LeituraWhereInput>
  }

  export type PrecipitacaoOrderByWithRelationInput = {
    id?: SortOrder
    sensor?: SortOrder
    valor?: SortOrder
    unidade?: SortOrder
    ordemGrandeza?: SortOrder
    leituraId?: SortOrder
    leitura?: LeituraOrderByWithRelationInput
  }

  export type PrecipitacaoWhereUniqueInput = {
    id?: number
  }

  export type PrecipitacaoOrderByWithAggregationInput = {
    id?: SortOrder
    sensor?: SortOrder
    valor?: SortOrder
    unidade?: SortOrder
    ordemGrandeza?: SortOrder
    leituraId?: SortOrder
    _count?: PrecipitacaoCountOrderByAggregateInput
    _avg?: PrecipitacaoAvgOrderByAggregateInput
    _max?: PrecipitacaoMaxOrderByAggregateInput
    _min?: PrecipitacaoMinOrderByAggregateInput
    _sum?: PrecipitacaoSumOrderByAggregateInput
  }

  export type PrecipitacaoScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PrecipitacaoScalarWhereWithAggregatesInput>
    OR?: Enumerable<PrecipitacaoScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PrecipitacaoScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    sensor?: StringWithAggregatesFilter | string
    valor?: IntWithAggregatesFilter | number
    unidade?: StringWithAggregatesFilter | string
    ordemGrandeza?: IntWithAggregatesFilter | number
    leituraId?: IntWithAggregatesFilter | number
  }

  export type UmidadeSoloWhereInput = {
    AND?: Enumerable<UmidadeSoloWhereInput>
    OR?: Enumerable<UmidadeSoloWhereInput>
    NOT?: Enumerable<UmidadeSoloWhereInput>
    id?: IntFilter | number
    sensor?: StringFilter | string
    valor?: IntFilter | number
    unidade?: StringFilter | string
    ordemGrandeza?: IntFilter | number
    leituraId?: IntFilter | number
    leitura?: XOR<LeituraRelationFilter, LeituraWhereInput>
  }

  export type UmidadeSoloOrderByWithRelationInput = {
    id?: SortOrder
    sensor?: SortOrder
    valor?: SortOrder
    unidade?: SortOrder
    ordemGrandeza?: SortOrder
    leituraId?: SortOrder
    leitura?: LeituraOrderByWithRelationInput
  }

  export type UmidadeSoloWhereUniqueInput = {
    id?: number
  }

  export type UmidadeSoloOrderByWithAggregationInput = {
    id?: SortOrder
    sensor?: SortOrder
    valor?: SortOrder
    unidade?: SortOrder
    ordemGrandeza?: SortOrder
    leituraId?: SortOrder
    _count?: UmidadeSoloCountOrderByAggregateInput
    _avg?: UmidadeSoloAvgOrderByAggregateInput
    _max?: UmidadeSoloMaxOrderByAggregateInput
    _min?: UmidadeSoloMinOrderByAggregateInput
    _sum?: UmidadeSoloSumOrderByAggregateInput
  }

  export type UmidadeSoloScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UmidadeSoloScalarWhereWithAggregatesInput>
    OR?: Enumerable<UmidadeSoloScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UmidadeSoloScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    sensor?: StringWithAggregatesFilter | string
    valor?: IntWithAggregatesFilter | number
    unidade?: StringWithAggregatesFilter | string
    ordemGrandeza?: IntWithAggregatesFilter | number
    leituraId?: IntWithAggregatesFilter | number
  }

  export type UmidadeRelativaWhereInput = {
    AND?: Enumerable<UmidadeRelativaWhereInput>
    OR?: Enumerable<UmidadeRelativaWhereInput>
    NOT?: Enumerable<UmidadeRelativaWhereInput>
    id?: IntFilter | number
    sensor?: StringFilter | string
    valor?: IntFilter | number
    unidade?: StringFilter | string
    ordemGrandeza?: IntFilter | number
    leituraId?: IntFilter | number
    leitura?: XOR<LeituraRelationFilter, LeituraWhereInput>
  }

  export type UmidadeRelativaOrderByWithRelationInput = {
    id?: SortOrder
    sensor?: SortOrder
    valor?: SortOrder
    unidade?: SortOrder
    ordemGrandeza?: SortOrder
    leituraId?: SortOrder
    leitura?: LeituraOrderByWithRelationInput
  }

  export type UmidadeRelativaWhereUniqueInput = {
    id?: number
  }

  export type UmidadeRelativaOrderByWithAggregationInput = {
    id?: SortOrder
    sensor?: SortOrder
    valor?: SortOrder
    unidade?: SortOrder
    ordemGrandeza?: SortOrder
    leituraId?: SortOrder
    _count?: UmidadeRelativaCountOrderByAggregateInput
    _avg?: UmidadeRelativaAvgOrderByAggregateInput
    _max?: UmidadeRelativaMaxOrderByAggregateInput
    _min?: UmidadeRelativaMinOrderByAggregateInput
    _sum?: UmidadeRelativaSumOrderByAggregateInput
  }

  export type UmidadeRelativaScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UmidadeRelativaScalarWhereWithAggregatesInput>
    OR?: Enumerable<UmidadeRelativaScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UmidadeRelativaScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    sensor?: StringWithAggregatesFilter | string
    valor?: IntWithAggregatesFilter | number
    unidade?: StringWithAggregatesFilter | string
    ordemGrandeza?: IntWithAggregatesFilter | number
    leituraId?: IntWithAggregatesFilter | number
  }

  export type LeituraCreateInput = {
    createdAt?: Date | string
    Temperatura?: TemperaturaCreateNestedManyWithoutLeituraInput
    Pressao?: PressaoCreateNestedManyWithoutLeituraInput
    Altitude?: AltitudeCreateNestedManyWithoutLeituraInput
    VelocidadeVento?: VelocidadeVentoCreateNestedManyWithoutLeituraInput
    DirecaoVento?: DirecaoVentoCreateNestedManyWithoutLeituraInput
    Precipitacao?: PrecipitacaoCreateNestedManyWithoutLeituraInput
    UmidadeSolo?: UmidadeSoloCreateNestedManyWithoutLeituraInput
    UmidadeRelativa?: UmidadeRelativaCreateNestedManyWithoutLeituraInput
  }

  export type LeituraUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    Temperatura?: TemperaturaUncheckedCreateNestedManyWithoutLeituraInput
    Pressao?: PressaoUncheckedCreateNestedManyWithoutLeituraInput
    Altitude?: AltitudeUncheckedCreateNestedManyWithoutLeituraInput
    VelocidadeVento?: VelocidadeVentoUncheckedCreateNestedManyWithoutLeituraInput
    DirecaoVento?: DirecaoVentoUncheckedCreateNestedManyWithoutLeituraInput
    Precipitacao?: PrecipitacaoUncheckedCreateNestedManyWithoutLeituraInput
    UmidadeSolo?: UmidadeSoloUncheckedCreateNestedManyWithoutLeituraInput
    UmidadeRelativa?: UmidadeRelativaUncheckedCreateNestedManyWithoutLeituraInput
  }

  export type LeituraUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Temperatura?: TemperaturaUpdateManyWithoutLeituraInput
    Pressao?: PressaoUpdateManyWithoutLeituraInput
    Altitude?: AltitudeUpdateManyWithoutLeituraInput
    VelocidadeVento?: VelocidadeVentoUpdateManyWithoutLeituraInput
    DirecaoVento?: DirecaoVentoUpdateManyWithoutLeituraInput
    Precipitacao?: PrecipitacaoUpdateManyWithoutLeituraInput
    UmidadeSolo?: UmidadeSoloUpdateManyWithoutLeituraInput
    UmidadeRelativa?: UmidadeRelativaUpdateManyWithoutLeituraInput
  }

  export type LeituraUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Temperatura?: TemperaturaUncheckedUpdateManyWithoutLeituraInput
    Pressao?: PressaoUncheckedUpdateManyWithoutLeituraInput
    Altitude?: AltitudeUncheckedUpdateManyWithoutLeituraInput
    VelocidadeVento?: VelocidadeVentoUncheckedUpdateManyWithoutLeituraInput
    DirecaoVento?: DirecaoVentoUncheckedUpdateManyWithoutLeituraInput
    Precipitacao?: PrecipitacaoUncheckedUpdateManyWithoutLeituraInput
    UmidadeSolo?: UmidadeSoloUncheckedUpdateManyWithoutLeituraInput
    UmidadeRelativa?: UmidadeRelativaUncheckedUpdateManyWithoutLeituraInput
  }

  export type LeituraUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeituraUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemperaturaCreateInput = {
    sensor: string
    valor: number
    unidade: string
    ordemGrandeza: number
    leitura: LeituraCreateNestedOneWithoutTemperaturaInput
  }

  export type TemperaturaUncheckedCreateInput = {
    id?: number
    sensor: string
    valor: number
    unidade: string
    ordemGrandeza: number
    leituraId: number
  }

  export type TemperaturaUpdateInput = {
    sensor?: StringFieldUpdateOperationsInput | string
    valor?: IntFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    ordemGrandeza?: IntFieldUpdateOperationsInput | number
    leitura?: LeituraUpdateOneRequiredWithoutTemperaturaInput
  }

  export type TemperaturaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sensor?: StringFieldUpdateOperationsInput | string
    valor?: IntFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    ordemGrandeza?: IntFieldUpdateOperationsInput | number
    leituraId?: IntFieldUpdateOperationsInput | number
  }

  export type TemperaturaUpdateManyMutationInput = {
    sensor?: StringFieldUpdateOperationsInput | string
    valor?: IntFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    ordemGrandeza?: IntFieldUpdateOperationsInput | number
  }

  export type TemperaturaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sensor?: StringFieldUpdateOperationsInput | string
    valor?: IntFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    ordemGrandeza?: IntFieldUpdateOperationsInput | number
    leituraId?: IntFieldUpdateOperationsInput | number
  }

  export type PressaoCreateInput = {
    sensor: string
    valor: number
    unidade: string
    ordemGrandeza: number
    leitura: LeituraCreateNestedOneWithoutPressaoInput
  }

  export type PressaoUncheckedCreateInput = {
    id?: number
    sensor: string
    valor: number
    unidade: string
    ordemGrandeza: number
    leituraId: number
  }

  export type PressaoUpdateInput = {
    sensor?: StringFieldUpdateOperationsInput | string
    valor?: IntFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    ordemGrandeza?: IntFieldUpdateOperationsInput | number
    leitura?: LeituraUpdateOneRequiredWithoutPressaoInput
  }

  export type PressaoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sensor?: StringFieldUpdateOperationsInput | string
    valor?: IntFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    ordemGrandeza?: IntFieldUpdateOperationsInput | number
    leituraId?: IntFieldUpdateOperationsInput | number
  }

  export type PressaoUpdateManyMutationInput = {
    sensor?: StringFieldUpdateOperationsInput | string
    valor?: IntFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    ordemGrandeza?: IntFieldUpdateOperationsInput | number
  }

  export type PressaoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sensor?: StringFieldUpdateOperationsInput | string
    valor?: IntFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    ordemGrandeza?: IntFieldUpdateOperationsInput | number
    leituraId?: IntFieldUpdateOperationsInput | number
  }

  export type AltitudeCreateInput = {
    sensor: string
    valor: number
    unidade: string
    ordemGrandeza: number
    leitura: LeituraCreateNestedOneWithoutAltitudeInput
  }

  export type AltitudeUncheckedCreateInput = {
    id?: number
    sensor: string
    valor: number
    unidade: string
    ordemGrandeza: number
    leituraId: number
  }

  export type AltitudeUpdateInput = {
    sensor?: StringFieldUpdateOperationsInput | string
    valor?: IntFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    ordemGrandeza?: IntFieldUpdateOperationsInput | number
    leitura?: LeituraUpdateOneRequiredWithoutAltitudeInput
  }

  export type AltitudeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sensor?: StringFieldUpdateOperationsInput | string
    valor?: IntFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    ordemGrandeza?: IntFieldUpdateOperationsInput | number
    leituraId?: IntFieldUpdateOperationsInput | number
  }

  export type AltitudeUpdateManyMutationInput = {
    sensor?: StringFieldUpdateOperationsInput | string
    valor?: IntFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    ordemGrandeza?: IntFieldUpdateOperationsInput | number
  }

  export type AltitudeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sensor?: StringFieldUpdateOperationsInput | string
    valor?: IntFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    ordemGrandeza?: IntFieldUpdateOperationsInput | number
    leituraId?: IntFieldUpdateOperationsInput | number
  }

  export type VelocidadeVentoCreateInput = {
    sensor: string
    media: number
    maximo: number
    unidade: string
    ordemGrandeza: number
    leitura: LeituraCreateNestedOneWithoutVelocidadeVentoInput
  }

  export type VelocidadeVentoUncheckedCreateInput = {
    id?: number
    sensor: string
    media: number
    maximo: number
    unidade: string
    ordemGrandeza: number
    leituraId: number
  }

  export type VelocidadeVentoUpdateInput = {
    sensor?: StringFieldUpdateOperationsInput | string
    media?: IntFieldUpdateOperationsInput | number
    maximo?: IntFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    ordemGrandeza?: IntFieldUpdateOperationsInput | number
    leitura?: LeituraUpdateOneRequiredWithoutVelocidadeVentoInput
  }

  export type VelocidadeVentoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sensor?: StringFieldUpdateOperationsInput | string
    media?: IntFieldUpdateOperationsInput | number
    maximo?: IntFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    ordemGrandeza?: IntFieldUpdateOperationsInput | number
    leituraId?: IntFieldUpdateOperationsInput | number
  }

  export type VelocidadeVentoUpdateManyMutationInput = {
    sensor?: StringFieldUpdateOperationsInput | string
    media?: IntFieldUpdateOperationsInput | number
    maximo?: IntFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    ordemGrandeza?: IntFieldUpdateOperationsInput | number
  }

  export type VelocidadeVentoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sensor?: StringFieldUpdateOperationsInput | string
    media?: IntFieldUpdateOperationsInput | number
    maximo?: IntFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    ordemGrandeza?: IntFieldUpdateOperationsInput | number
    leituraId?: IntFieldUpdateOperationsInput | number
  }

  export type DirecaoVentoCreateInput = {
    sensor: string
    valor: number
    unidade: string
    ordemGrandeza: number
    leitura: LeituraCreateNestedOneWithoutDirecaoVentoInput
  }

  export type DirecaoVentoUncheckedCreateInput = {
    id?: number
    sensor: string
    valor: number
    unidade: string
    ordemGrandeza: number
    leituraId: number
  }

  export type DirecaoVentoUpdateInput = {
    sensor?: StringFieldUpdateOperationsInput | string
    valor?: IntFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    ordemGrandeza?: IntFieldUpdateOperationsInput | number
    leitura?: LeituraUpdateOneRequiredWithoutDirecaoVentoInput
  }

  export type DirecaoVentoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sensor?: StringFieldUpdateOperationsInput | string
    valor?: IntFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    ordemGrandeza?: IntFieldUpdateOperationsInput | number
    leituraId?: IntFieldUpdateOperationsInput | number
  }

  export type DirecaoVentoUpdateManyMutationInput = {
    sensor?: StringFieldUpdateOperationsInput | string
    valor?: IntFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    ordemGrandeza?: IntFieldUpdateOperationsInput | number
  }

  export type DirecaoVentoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sensor?: StringFieldUpdateOperationsInput | string
    valor?: IntFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    ordemGrandeza?: IntFieldUpdateOperationsInput | number
    leituraId?: IntFieldUpdateOperationsInput | number
  }

  export type PrecipitacaoCreateInput = {
    sensor: string
    valor: number
    unidade: string
    ordemGrandeza: number
    leitura: LeituraCreateNestedOneWithoutPrecipitacaoInput
  }

  export type PrecipitacaoUncheckedCreateInput = {
    id?: number
    sensor: string
    valor: number
    unidade: string
    ordemGrandeza: number
    leituraId: number
  }

  export type PrecipitacaoUpdateInput = {
    sensor?: StringFieldUpdateOperationsInput | string
    valor?: IntFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    ordemGrandeza?: IntFieldUpdateOperationsInput | number
    leitura?: LeituraUpdateOneRequiredWithoutPrecipitacaoInput
  }

  export type PrecipitacaoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sensor?: StringFieldUpdateOperationsInput | string
    valor?: IntFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    ordemGrandeza?: IntFieldUpdateOperationsInput | number
    leituraId?: IntFieldUpdateOperationsInput | number
  }

  export type PrecipitacaoUpdateManyMutationInput = {
    sensor?: StringFieldUpdateOperationsInput | string
    valor?: IntFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    ordemGrandeza?: IntFieldUpdateOperationsInput | number
  }

  export type PrecipitacaoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sensor?: StringFieldUpdateOperationsInput | string
    valor?: IntFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    ordemGrandeza?: IntFieldUpdateOperationsInput | number
    leituraId?: IntFieldUpdateOperationsInput | number
  }

  export type UmidadeSoloCreateInput = {
    sensor: string
    valor: number
    unidade: string
    ordemGrandeza: number
    leitura: LeituraCreateNestedOneWithoutUmidadeSoloInput
  }

  export type UmidadeSoloUncheckedCreateInput = {
    id?: number
    sensor: string
    valor: number
    unidade: string
    ordemGrandeza: number
    leituraId: number
  }

  export type UmidadeSoloUpdateInput = {
    sensor?: StringFieldUpdateOperationsInput | string
    valor?: IntFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    ordemGrandeza?: IntFieldUpdateOperationsInput | number
    leitura?: LeituraUpdateOneRequiredWithoutUmidadeSoloInput
  }

  export type UmidadeSoloUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sensor?: StringFieldUpdateOperationsInput | string
    valor?: IntFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    ordemGrandeza?: IntFieldUpdateOperationsInput | number
    leituraId?: IntFieldUpdateOperationsInput | number
  }

  export type UmidadeSoloUpdateManyMutationInput = {
    sensor?: StringFieldUpdateOperationsInput | string
    valor?: IntFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    ordemGrandeza?: IntFieldUpdateOperationsInput | number
  }

  export type UmidadeSoloUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sensor?: StringFieldUpdateOperationsInput | string
    valor?: IntFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    ordemGrandeza?: IntFieldUpdateOperationsInput | number
    leituraId?: IntFieldUpdateOperationsInput | number
  }

  export type UmidadeRelativaCreateInput = {
    sensor: string
    valor: number
    unidade: string
    ordemGrandeza: number
    leitura: LeituraCreateNestedOneWithoutUmidadeRelativaInput
  }

  export type UmidadeRelativaUncheckedCreateInput = {
    id?: number
    sensor: string
    valor: number
    unidade: string
    ordemGrandeza: number
    leituraId: number
  }

  export type UmidadeRelativaUpdateInput = {
    sensor?: StringFieldUpdateOperationsInput | string
    valor?: IntFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    ordemGrandeza?: IntFieldUpdateOperationsInput | number
    leitura?: LeituraUpdateOneRequiredWithoutUmidadeRelativaInput
  }

  export type UmidadeRelativaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sensor?: StringFieldUpdateOperationsInput | string
    valor?: IntFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    ordemGrandeza?: IntFieldUpdateOperationsInput | number
    leituraId?: IntFieldUpdateOperationsInput | number
  }

  export type UmidadeRelativaUpdateManyMutationInput = {
    sensor?: StringFieldUpdateOperationsInput | string
    valor?: IntFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    ordemGrandeza?: IntFieldUpdateOperationsInput | number
  }

  export type UmidadeRelativaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sensor?: StringFieldUpdateOperationsInput | string
    valor?: IntFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    ordemGrandeza?: IntFieldUpdateOperationsInput | number
    leituraId?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type TemperaturaListRelationFilter = {
    every?: TemperaturaWhereInput
    some?: TemperaturaWhereInput
    none?: TemperaturaWhereInput
  }

  export type PressaoListRelationFilter = {
    every?: PressaoWhereInput
    some?: PressaoWhereInput
    none?: PressaoWhereInput
  }

  export type AltitudeListRelationFilter = {
    every?: AltitudeWhereInput
    some?: AltitudeWhereInput
    none?: AltitudeWhereInput
  }

  export type VelocidadeVentoListRelationFilter = {
    every?: VelocidadeVentoWhereInput
    some?: VelocidadeVentoWhereInput
    none?: VelocidadeVentoWhereInput
  }

  export type DirecaoVentoListRelationFilter = {
    every?: DirecaoVentoWhereInput
    some?: DirecaoVentoWhereInput
    none?: DirecaoVentoWhereInput
  }

  export type PrecipitacaoListRelationFilter = {
    every?: PrecipitacaoWhereInput
    some?: PrecipitacaoWhereInput
    none?: PrecipitacaoWhereInput
  }

  export type UmidadeSoloListRelationFilter = {
    every?: UmidadeSoloWhereInput
    some?: UmidadeSoloWhereInput
    none?: UmidadeSoloWhereInput
  }

  export type UmidadeRelativaListRelationFilter = {
    every?: UmidadeRelativaWhereInput
    some?: UmidadeRelativaWhereInput
    none?: UmidadeRelativaWhereInput
  }

  export type TemperaturaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PressaoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AltitudeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VelocidadeVentoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DirecaoVentoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PrecipitacaoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UmidadeSoloOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UmidadeRelativaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeituraCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
  }

  export type LeituraAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LeituraMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
  }

  export type LeituraMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
  }

  export type LeituraSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type LeituraRelationFilter = {
    is?: LeituraWhereInput
    isNot?: LeituraWhereInput
  }

  export type TemperaturaCountOrderByAggregateInput = {
    id?: SortOrder
    sensor?: SortOrder
    valor?: SortOrder
    unidade?: SortOrder
    ordemGrandeza?: SortOrder
    leituraId?: SortOrder
  }

  export type TemperaturaAvgOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    ordemGrandeza?: SortOrder
    leituraId?: SortOrder
  }

  export type TemperaturaMaxOrderByAggregateInput = {
    id?: SortOrder
    sensor?: SortOrder
    valor?: SortOrder
    unidade?: SortOrder
    ordemGrandeza?: SortOrder
    leituraId?: SortOrder
  }

  export type TemperaturaMinOrderByAggregateInput = {
    id?: SortOrder
    sensor?: SortOrder
    valor?: SortOrder
    unidade?: SortOrder
    ordemGrandeza?: SortOrder
    leituraId?: SortOrder
  }

  export type TemperaturaSumOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    ordemGrandeza?: SortOrder
    leituraId?: SortOrder
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type PressaoCountOrderByAggregateInput = {
    id?: SortOrder
    sensor?: SortOrder
    valor?: SortOrder
    unidade?: SortOrder
    ordemGrandeza?: SortOrder
    leituraId?: SortOrder
  }

  export type PressaoAvgOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    ordemGrandeza?: SortOrder
    leituraId?: SortOrder
  }

  export type PressaoMaxOrderByAggregateInput = {
    id?: SortOrder
    sensor?: SortOrder
    valor?: SortOrder
    unidade?: SortOrder
    ordemGrandeza?: SortOrder
    leituraId?: SortOrder
  }

  export type PressaoMinOrderByAggregateInput = {
    id?: SortOrder
    sensor?: SortOrder
    valor?: SortOrder
    unidade?: SortOrder
    ordemGrandeza?: SortOrder
    leituraId?: SortOrder
  }

  export type PressaoSumOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    ordemGrandeza?: SortOrder
    leituraId?: SortOrder
  }

  export type AltitudeCountOrderByAggregateInput = {
    id?: SortOrder
    sensor?: SortOrder
    valor?: SortOrder
    unidade?: SortOrder
    ordemGrandeza?: SortOrder
    leituraId?: SortOrder
  }

  export type AltitudeAvgOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    ordemGrandeza?: SortOrder
    leituraId?: SortOrder
  }

  export type AltitudeMaxOrderByAggregateInput = {
    id?: SortOrder
    sensor?: SortOrder
    valor?: SortOrder
    unidade?: SortOrder
    ordemGrandeza?: SortOrder
    leituraId?: SortOrder
  }

  export type AltitudeMinOrderByAggregateInput = {
    id?: SortOrder
    sensor?: SortOrder
    valor?: SortOrder
    unidade?: SortOrder
    ordemGrandeza?: SortOrder
    leituraId?: SortOrder
  }

  export type AltitudeSumOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    ordemGrandeza?: SortOrder
    leituraId?: SortOrder
  }

  export type VelocidadeVentoCountOrderByAggregateInput = {
    id?: SortOrder
    sensor?: SortOrder
    media?: SortOrder
    maximo?: SortOrder
    unidade?: SortOrder
    ordemGrandeza?: SortOrder
    leituraId?: SortOrder
  }

  export type VelocidadeVentoAvgOrderByAggregateInput = {
    id?: SortOrder
    media?: SortOrder
    maximo?: SortOrder
    ordemGrandeza?: SortOrder
    leituraId?: SortOrder
  }

  export type VelocidadeVentoMaxOrderByAggregateInput = {
    id?: SortOrder
    sensor?: SortOrder
    media?: SortOrder
    maximo?: SortOrder
    unidade?: SortOrder
    ordemGrandeza?: SortOrder
    leituraId?: SortOrder
  }

  export type VelocidadeVentoMinOrderByAggregateInput = {
    id?: SortOrder
    sensor?: SortOrder
    media?: SortOrder
    maximo?: SortOrder
    unidade?: SortOrder
    ordemGrandeza?: SortOrder
    leituraId?: SortOrder
  }

  export type VelocidadeVentoSumOrderByAggregateInput = {
    id?: SortOrder
    media?: SortOrder
    maximo?: SortOrder
    ordemGrandeza?: SortOrder
    leituraId?: SortOrder
  }

  export type DirecaoVentoCountOrderByAggregateInput = {
    id?: SortOrder
    sensor?: SortOrder
    valor?: SortOrder
    unidade?: SortOrder
    ordemGrandeza?: SortOrder
    leituraId?: SortOrder
  }

  export type DirecaoVentoAvgOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    ordemGrandeza?: SortOrder
    leituraId?: SortOrder
  }

  export type DirecaoVentoMaxOrderByAggregateInput = {
    id?: SortOrder
    sensor?: SortOrder
    valor?: SortOrder
    unidade?: SortOrder
    ordemGrandeza?: SortOrder
    leituraId?: SortOrder
  }

  export type DirecaoVentoMinOrderByAggregateInput = {
    id?: SortOrder
    sensor?: SortOrder
    valor?: SortOrder
    unidade?: SortOrder
    ordemGrandeza?: SortOrder
    leituraId?: SortOrder
  }

  export type DirecaoVentoSumOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    ordemGrandeza?: SortOrder
    leituraId?: SortOrder
  }

  export type PrecipitacaoCountOrderByAggregateInput = {
    id?: SortOrder
    sensor?: SortOrder
    valor?: SortOrder
    unidade?: SortOrder
    ordemGrandeza?: SortOrder
    leituraId?: SortOrder
  }

  export type PrecipitacaoAvgOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    ordemGrandeza?: SortOrder
    leituraId?: SortOrder
  }

  export type PrecipitacaoMaxOrderByAggregateInput = {
    id?: SortOrder
    sensor?: SortOrder
    valor?: SortOrder
    unidade?: SortOrder
    ordemGrandeza?: SortOrder
    leituraId?: SortOrder
  }

  export type PrecipitacaoMinOrderByAggregateInput = {
    id?: SortOrder
    sensor?: SortOrder
    valor?: SortOrder
    unidade?: SortOrder
    ordemGrandeza?: SortOrder
    leituraId?: SortOrder
  }

  export type PrecipitacaoSumOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    ordemGrandeza?: SortOrder
    leituraId?: SortOrder
  }

  export type UmidadeSoloCountOrderByAggregateInput = {
    id?: SortOrder
    sensor?: SortOrder
    valor?: SortOrder
    unidade?: SortOrder
    ordemGrandeza?: SortOrder
    leituraId?: SortOrder
  }

  export type UmidadeSoloAvgOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    ordemGrandeza?: SortOrder
    leituraId?: SortOrder
  }

  export type UmidadeSoloMaxOrderByAggregateInput = {
    id?: SortOrder
    sensor?: SortOrder
    valor?: SortOrder
    unidade?: SortOrder
    ordemGrandeza?: SortOrder
    leituraId?: SortOrder
  }

  export type UmidadeSoloMinOrderByAggregateInput = {
    id?: SortOrder
    sensor?: SortOrder
    valor?: SortOrder
    unidade?: SortOrder
    ordemGrandeza?: SortOrder
    leituraId?: SortOrder
  }

  export type UmidadeSoloSumOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    ordemGrandeza?: SortOrder
    leituraId?: SortOrder
  }

  export type UmidadeRelativaCountOrderByAggregateInput = {
    id?: SortOrder
    sensor?: SortOrder
    valor?: SortOrder
    unidade?: SortOrder
    ordemGrandeza?: SortOrder
    leituraId?: SortOrder
  }

  export type UmidadeRelativaAvgOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    ordemGrandeza?: SortOrder
    leituraId?: SortOrder
  }

  export type UmidadeRelativaMaxOrderByAggregateInput = {
    id?: SortOrder
    sensor?: SortOrder
    valor?: SortOrder
    unidade?: SortOrder
    ordemGrandeza?: SortOrder
    leituraId?: SortOrder
  }

  export type UmidadeRelativaMinOrderByAggregateInput = {
    id?: SortOrder
    sensor?: SortOrder
    valor?: SortOrder
    unidade?: SortOrder
    ordemGrandeza?: SortOrder
    leituraId?: SortOrder
  }

  export type UmidadeRelativaSumOrderByAggregateInput = {
    id?: SortOrder
    valor?: SortOrder
    ordemGrandeza?: SortOrder
    leituraId?: SortOrder
  }

  export type TemperaturaCreateNestedManyWithoutLeituraInput = {
    create?: XOR<Enumerable<TemperaturaCreateWithoutLeituraInput>, Enumerable<TemperaturaUncheckedCreateWithoutLeituraInput>>
    connectOrCreate?: Enumerable<TemperaturaCreateOrConnectWithoutLeituraInput>
    connect?: Enumerable<TemperaturaWhereUniqueInput>
  }

  export type PressaoCreateNestedManyWithoutLeituraInput = {
    create?: XOR<Enumerable<PressaoCreateWithoutLeituraInput>, Enumerable<PressaoUncheckedCreateWithoutLeituraInput>>
    connectOrCreate?: Enumerable<PressaoCreateOrConnectWithoutLeituraInput>
    connect?: Enumerable<PressaoWhereUniqueInput>
  }

  export type AltitudeCreateNestedManyWithoutLeituraInput = {
    create?: XOR<Enumerable<AltitudeCreateWithoutLeituraInput>, Enumerable<AltitudeUncheckedCreateWithoutLeituraInput>>
    connectOrCreate?: Enumerable<AltitudeCreateOrConnectWithoutLeituraInput>
    connect?: Enumerable<AltitudeWhereUniqueInput>
  }

  export type VelocidadeVentoCreateNestedManyWithoutLeituraInput = {
    create?: XOR<Enumerable<VelocidadeVentoCreateWithoutLeituraInput>, Enumerable<VelocidadeVentoUncheckedCreateWithoutLeituraInput>>
    connectOrCreate?: Enumerable<VelocidadeVentoCreateOrConnectWithoutLeituraInput>
    connect?: Enumerable<VelocidadeVentoWhereUniqueInput>
  }

  export type DirecaoVentoCreateNestedManyWithoutLeituraInput = {
    create?: XOR<Enumerable<DirecaoVentoCreateWithoutLeituraInput>, Enumerable<DirecaoVentoUncheckedCreateWithoutLeituraInput>>
    connectOrCreate?: Enumerable<DirecaoVentoCreateOrConnectWithoutLeituraInput>
    connect?: Enumerable<DirecaoVentoWhereUniqueInput>
  }

  export type PrecipitacaoCreateNestedManyWithoutLeituraInput = {
    create?: XOR<Enumerable<PrecipitacaoCreateWithoutLeituraInput>, Enumerable<PrecipitacaoUncheckedCreateWithoutLeituraInput>>
    connectOrCreate?: Enumerable<PrecipitacaoCreateOrConnectWithoutLeituraInput>
    connect?: Enumerable<PrecipitacaoWhereUniqueInput>
  }

  export type UmidadeSoloCreateNestedManyWithoutLeituraInput = {
    create?: XOR<Enumerable<UmidadeSoloCreateWithoutLeituraInput>, Enumerable<UmidadeSoloUncheckedCreateWithoutLeituraInput>>
    connectOrCreate?: Enumerable<UmidadeSoloCreateOrConnectWithoutLeituraInput>
    connect?: Enumerable<UmidadeSoloWhereUniqueInput>
  }

  export type UmidadeRelativaCreateNestedManyWithoutLeituraInput = {
    create?: XOR<Enumerable<UmidadeRelativaCreateWithoutLeituraInput>, Enumerable<UmidadeRelativaUncheckedCreateWithoutLeituraInput>>
    connectOrCreate?: Enumerable<UmidadeRelativaCreateOrConnectWithoutLeituraInput>
    connect?: Enumerable<UmidadeRelativaWhereUniqueInput>
  }

  export type TemperaturaUncheckedCreateNestedManyWithoutLeituraInput = {
    create?: XOR<Enumerable<TemperaturaCreateWithoutLeituraInput>, Enumerable<TemperaturaUncheckedCreateWithoutLeituraInput>>
    connectOrCreate?: Enumerable<TemperaturaCreateOrConnectWithoutLeituraInput>
    connect?: Enumerable<TemperaturaWhereUniqueInput>
  }

  export type PressaoUncheckedCreateNestedManyWithoutLeituraInput = {
    create?: XOR<Enumerable<PressaoCreateWithoutLeituraInput>, Enumerable<PressaoUncheckedCreateWithoutLeituraInput>>
    connectOrCreate?: Enumerable<PressaoCreateOrConnectWithoutLeituraInput>
    connect?: Enumerable<PressaoWhereUniqueInput>
  }

  export type AltitudeUncheckedCreateNestedManyWithoutLeituraInput = {
    create?: XOR<Enumerable<AltitudeCreateWithoutLeituraInput>, Enumerable<AltitudeUncheckedCreateWithoutLeituraInput>>
    connectOrCreate?: Enumerable<AltitudeCreateOrConnectWithoutLeituraInput>
    connect?: Enumerable<AltitudeWhereUniqueInput>
  }

  export type VelocidadeVentoUncheckedCreateNestedManyWithoutLeituraInput = {
    create?: XOR<Enumerable<VelocidadeVentoCreateWithoutLeituraInput>, Enumerable<VelocidadeVentoUncheckedCreateWithoutLeituraInput>>
    connectOrCreate?: Enumerable<VelocidadeVentoCreateOrConnectWithoutLeituraInput>
    connect?: Enumerable<VelocidadeVentoWhereUniqueInput>
  }

  export type DirecaoVentoUncheckedCreateNestedManyWithoutLeituraInput = {
    create?: XOR<Enumerable<DirecaoVentoCreateWithoutLeituraInput>, Enumerable<DirecaoVentoUncheckedCreateWithoutLeituraInput>>
    connectOrCreate?: Enumerable<DirecaoVentoCreateOrConnectWithoutLeituraInput>
    connect?: Enumerable<DirecaoVentoWhereUniqueInput>
  }

  export type PrecipitacaoUncheckedCreateNestedManyWithoutLeituraInput = {
    create?: XOR<Enumerable<PrecipitacaoCreateWithoutLeituraInput>, Enumerable<PrecipitacaoUncheckedCreateWithoutLeituraInput>>
    connectOrCreate?: Enumerable<PrecipitacaoCreateOrConnectWithoutLeituraInput>
    connect?: Enumerable<PrecipitacaoWhereUniqueInput>
  }

  export type UmidadeSoloUncheckedCreateNestedManyWithoutLeituraInput = {
    create?: XOR<Enumerable<UmidadeSoloCreateWithoutLeituraInput>, Enumerable<UmidadeSoloUncheckedCreateWithoutLeituraInput>>
    connectOrCreate?: Enumerable<UmidadeSoloCreateOrConnectWithoutLeituraInput>
    connect?: Enumerable<UmidadeSoloWhereUniqueInput>
  }

  export type UmidadeRelativaUncheckedCreateNestedManyWithoutLeituraInput = {
    create?: XOR<Enumerable<UmidadeRelativaCreateWithoutLeituraInput>, Enumerable<UmidadeRelativaUncheckedCreateWithoutLeituraInput>>
    connectOrCreate?: Enumerable<UmidadeRelativaCreateOrConnectWithoutLeituraInput>
    connect?: Enumerable<UmidadeRelativaWhereUniqueInput>
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type TemperaturaUpdateManyWithoutLeituraInput = {
    create?: XOR<Enumerable<TemperaturaCreateWithoutLeituraInput>, Enumerable<TemperaturaUncheckedCreateWithoutLeituraInput>>
    connectOrCreate?: Enumerable<TemperaturaCreateOrConnectWithoutLeituraInput>
    upsert?: Enumerable<TemperaturaUpsertWithWhereUniqueWithoutLeituraInput>
    set?: Enumerable<TemperaturaWhereUniqueInput>
    disconnect?: Enumerable<TemperaturaWhereUniqueInput>
    delete?: Enumerable<TemperaturaWhereUniqueInput>
    connect?: Enumerable<TemperaturaWhereUniqueInput>
    update?: Enumerable<TemperaturaUpdateWithWhereUniqueWithoutLeituraInput>
    updateMany?: Enumerable<TemperaturaUpdateManyWithWhereWithoutLeituraInput>
    deleteMany?: Enumerable<TemperaturaScalarWhereInput>
  }

  export type PressaoUpdateManyWithoutLeituraInput = {
    create?: XOR<Enumerable<PressaoCreateWithoutLeituraInput>, Enumerable<PressaoUncheckedCreateWithoutLeituraInput>>
    connectOrCreate?: Enumerable<PressaoCreateOrConnectWithoutLeituraInput>
    upsert?: Enumerable<PressaoUpsertWithWhereUniqueWithoutLeituraInput>
    set?: Enumerable<PressaoWhereUniqueInput>
    disconnect?: Enumerable<PressaoWhereUniqueInput>
    delete?: Enumerable<PressaoWhereUniqueInput>
    connect?: Enumerable<PressaoWhereUniqueInput>
    update?: Enumerable<PressaoUpdateWithWhereUniqueWithoutLeituraInput>
    updateMany?: Enumerable<PressaoUpdateManyWithWhereWithoutLeituraInput>
    deleteMany?: Enumerable<PressaoScalarWhereInput>
  }

  export type AltitudeUpdateManyWithoutLeituraInput = {
    create?: XOR<Enumerable<AltitudeCreateWithoutLeituraInput>, Enumerable<AltitudeUncheckedCreateWithoutLeituraInput>>
    connectOrCreate?: Enumerable<AltitudeCreateOrConnectWithoutLeituraInput>
    upsert?: Enumerable<AltitudeUpsertWithWhereUniqueWithoutLeituraInput>
    set?: Enumerable<AltitudeWhereUniqueInput>
    disconnect?: Enumerable<AltitudeWhereUniqueInput>
    delete?: Enumerable<AltitudeWhereUniqueInput>
    connect?: Enumerable<AltitudeWhereUniqueInput>
    update?: Enumerable<AltitudeUpdateWithWhereUniqueWithoutLeituraInput>
    updateMany?: Enumerable<AltitudeUpdateManyWithWhereWithoutLeituraInput>
    deleteMany?: Enumerable<AltitudeScalarWhereInput>
  }

  export type VelocidadeVentoUpdateManyWithoutLeituraInput = {
    create?: XOR<Enumerable<VelocidadeVentoCreateWithoutLeituraInput>, Enumerable<VelocidadeVentoUncheckedCreateWithoutLeituraInput>>
    connectOrCreate?: Enumerable<VelocidadeVentoCreateOrConnectWithoutLeituraInput>
    upsert?: Enumerable<VelocidadeVentoUpsertWithWhereUniqueWithoutLeituraInput>
    set?: Enumerable<VelocidadeVentoWhereUniqueInput>
    disconnect?: Enumerable<VelocidadeVentoWhereUniqueInput>
    delete?: Enumerable<VelocidadeVentoWhereUniqueInput>
    connect?: Enumerable<VelocidadeVentoWhereUniqueInput>
    update?: Enumerable<VelocidadeVentoUpdateWithWhereUniqueWithoutLeituraInput>
    updateMany?: Enumerable<VelocidadeVentoUpdateManyWithWhereWithoutLeituraInput>
    deleteMany?: Enumerable<VelocidadeVentoScalarWhereInput>
  }

  export type DirecaoVentoUpdateManyWithoutLeituraInput = {
    create?: XOR<Enumerable<DirecaoVentoCreateWithoutLeituraInput>, Enumerable<DirecaoVentoUncheckedCreateWithoutLeituraInput>>
    connectOrCreate?: Enumerable<DirecaoVentoCreateOrConnectWithoutLeituraInput>
    upsert?: Enumerable<DirecaoVentoUpsertWithWhereUniqueWithoutLeituraInput>
    set?: Enumerable<DirecaoVentoWhereUniqueInput>
    disconnect?: Enumerable<DirecaoVentoWhereUniqueInput>
    delete?: Enumerable<DirecaoVentoWhereUniqueInput>
    connect?: Enumerable<DirecaoVentoWhereUniqueInput>
    update?: Enumerable<DirecaoVentoUpdateWithWhereUniqueWithoutLeituraInput>
    updateMany?: Enumerable<DirecaoVentoUpdateManyWithWhereWithoutLeituraInput>
    deleteMany?: Enumerable<DirecaoVentoScalarWhereInput>
  }

  export type PrecipitacaoUpdateManyWithoutLeituraInput = {
    create?: XOR<Enumerable<PrecipitacaoCreateWithoutLeituraInput>, Enumerable<PrecipitacaoUncheckedCreateWithoutLeituraInput>>
    connectOrCreate?: Enumerable<PrecipitacaoCreateOrConnectWithoutLeituraInput>
    upsert?: Enumerable<PrecipitacaoUpsertWithWhereUniqueWithoutLeituraInput>
    set?: Enumerable<PrecipitacaoWhereUniqueInput>
    disconnect?: Enumerable<PrecipitacaoWhereUniqueInput>
    delete?: Enumerable<PrecipitacaoWhereUniqueInput>
    connect?: Enumerable<PrecipitacaoWhereUniqueInput>
    update?: Enumerable<PrecipitacaoUpdateWithWhereUniqueWithoutLeituraInput>
    updateMany?: Enumerable<PrecipitacaoUpdateManyWithWhereWithoutLeituraInput>
    deleteMany?: Enumerable<PrecipitacaoScalarWhereInput>
  }

  export type UmidadeSoloUpdateManyWithoutLeituraInput = {
    create?: XOR<Enumerable<UmidadeSoloCreateWithoutLeituraInput>, Enumerable<UmidadeSoloUncheckedCreateWithoutLeituraInput>>
    connectOrCreate?: Enumerable<UmidadeSoloCreateOrConnectWithoutLeituraInput>
    upsert?: Enumerable<UmidadeSoloUpsertWithWhereUniqueWithoutLeituraInput>
    set?: Enumerable<UmidadeSoloWhereUniqueInput>
    disconnect?: Enumerable<UmidadeSoloWhereUniqueInput>
    delete?: Enumerable<UmidadeSoloWhereUniqueInput>
    connect?: Enumerable<UmidadeSoloWhereUniqueInput>
    update?: Enumerable<UmidadeSoloUpdateWithWhereUniqueWithoutLeituraInput>
    updateMany?: Enumerable<UmidadeSoloUpdateManyWithWhereWithoutLeituraInput>
    deleteMany?: Enumerable<UmidadeSoloScalarWhereInput>
  }

  export type UmidadeRelativaUpdateManyWithoutLeituraInput = {
    create?: XOR<Enumerable<UmidadeRelativaCreateWithoutLeituraInput>, Enumerable<UmidadeRelativaUncheckedCreateWithoutLeituraInput>>
    connectOrCreate?: Enumerable<UmidadeRelativaCreateOrConnectWithoutLeituraInput>
    upsert?: Enumerable<UmidadeRelativaUpsertWithWhereUniqueWithoutLeituraInput>
    set?: Enumerable<UmidadeRelativaWhereUniqueInput>
    disconnect?: Enumerable<UmidadeRelativaWhereUniqueInput>
    delete?: Enumerable<UmidadeRelativaWhereUniqueInput>
    connect?: Enumerable<UmidadeRelativaWhereUniqueInput>
    update?: Enumerable<UmidadeRelativaUpdateWithWhereUniqueWithoutLeituraInput>
    updateMany?: Enumerable<UmidadeRelativaUpdateManyWithWhereWithoutLeituraInput>
    deleteMany?: Enumerable<UmidadeRelativaScalarWhereInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TemperaturaUncheckedUpdateManyWithoutLeituraInput = {
    create?: XOR<Enumerable<TemperaturaCreateWithoutLeituraInput>, Enumerable<TemperaturaUncheckedCreateWithoutLeituraInput>>
    connectOrCreate?: Enumerable<TemperaturaCreateOrConnectWithoutLeituraInput>
    upsert?: Enumerable<TemperaturaUpsertWithWhereUniqueWithoutLeituraInput>
    set?: Enumerable<TemperaturaWhereUniqueInput>
    disconnect?: Enumerable<TemperaturaWhereUniqueInput>
    delete?: Enumerable<TemperaturaWhereUniqueInput>
    connect?: Enumerable<TemperaturaWhereUniqueInput>
    update?: Enumerable<TemperaturaUpdateWithWhereUniqueWithoutLeituraInput>
    updateMany?: Enumerable<TemperaturaUpdateManyWithWhereWithoutLeituraInput>
    deleteMany?: Enumerable<TemperaturaScalarWhereInput>
  }

  export type PressaoUncheckedUpdateManyWithoutLeituraInput = {
    create?: XOR<Enumerable<PressaoCreateWithoutLeituraInput>, Enumerable<PressaoUncheckedCreateWithoutLeituraInput>>
    connectOrCreate?: Enumerable<PressaoCreateOrConnectWithoutLeituraInput>
    upsert?: Enumerable<PressaoUpsertWithWhereUniqueWithoutLeituraInput>
    set?: Enumerable<PressaoWhereUniqueInput>
    disconnect?: Enumerable<PressaoWhereUniqueInput>
    delete?: Enumerable<PressaoWhereUniqueInput>
    connect?: Enumerable<PressaoWhereUniqueInput>
    update?: Enumerable<PressaoUpdateWithWhereUniqueWithoutLeituraInput>
    updateMany?: Enumerable<PressaoUpdateManyWithWhereWithoutLeituraInput>
    deleteMany?: Enumerable<PressaoScalarWhereInput>
  }

  export type AltitudeUncheckedUpdateManyWithoutLeituraInput = {
    create?: XOR<Enumerable<AltitudeCreateWithoutLeituraInput>, Enumerable<AltitudeUncheckedCreateWithoutLeituraInput>>
    connectOrCreate?: Enumerable<AltitudeCreateOrConnectWithoutLeituraInput>
    upsert?: Enumerable<AltitudeUpsertWithWhereUniqueWithoutLeituraInput>
    set?: Enumerable<AltitudeWhereUniqueInput>
    disconnect?: Enumerable<AltitudeWhereUniqueInput>
    delete?: Enumerable<AltitudeWhereUniqueInput>
    connect?: Enumerable<AltitudeWhereUniqueInput>
    update?: Enumerable<AltitudeUpdateWithWhereUniqueWithoutLeituraInput>
    updateMany?: Enumerable<AltitudeUpdateManyWithWhereWithoutLeituraInput>
    deleteMany?: Enumerable<AltitudeScalarWhereInput>
  }

  export type VelocidadeVentoUncheckedUpdateManyWithoutLeituraInput = {
    create?: XOR<Enumerable<VelocidadeVentoCreateWithoutLeituraInput>, Enumerable<VelocidadeVentoUncheckedCreateWithoutLeituraInput>>
    connectOrCreate?: Enumerable<VelocidadeVentoCreateOrConnectWithoutLeituraInput>
    upsert?: Enumerable<VelocidadeVentoUpsertWithWhereUniqueWithoutLeituraInput>
    set?: Enumerable<VelocidadeVentoWhereUniqueInput>
    disconnect?: Enumerable<VelocidadeVentoWhereUniqueInput>
    delete?: Enumerable<VelocidadeVentoWhereUniqueInput>
    connect?: Enumerable<VelocidadeVentoWhereUniqueInput>
    update?: Enumerable<VelocidadeVentoUpdateWithWhereUniqueWithoutLeituraInput>
    updateMany?: Enumerable<VelocidadeVentoUpdateManyWithWhereWithoutLeituraInput>
    deleteMany?: Enumerable<VelocidadeVentoScalarWhereInput>
  }

  export type DirecaoVentoUncheckedUpdateManyWithoutLeituraInput = {
    create?: XOR<Enumerable<DirecaoVentoCreateWithoutLeituraInput>, Enumerable<DirecaoVentoUncheckedCreateWithoutLeituraInput>>
    connectOrCreate?: Enumerable<DirecaoVentoCreateOrConnectWithoutLeituraInput>
    upsert?: Enumerable<DirecaoVentoUpsertWithWhereUniqueWithoutLeituraInput>
    set?: Enumerable<DirecaoVentoWhereUniqueInput>
    disconnect?: Enumerable<DirecaoVentoWhereUniqueInput>
    delete?: Enumerable<DirecaoVentoWhereUniqueInput>
    connect?: Enumerable<DirecaoVentoWhereUniqueInput>
    update?: Enumerable<DirecaoVentoUpdateWithWhereUniqueWithoutLeituraInput>
    updateMany?: Enumerable<DirecaoVentoUpdateManyWithWhereWithoutLeituraInput>
    deleteMany?: Enumerable<DirecaoVentoScalarWhereInput>
  }

  export type PrecipitacaoUncheckedUpdateManyWithoutLeituraInput = {
    create?: XOR<Enumerable<PrecipitacaoCreateWithoutLeituraInput>, Enumerable<PrecipitacaoUncheckedCreateWithoutLeituraInput>>
    connectOrCreate?: Enumerable<PrecipitacaoCreateOrConnectWithoutLeituraInput>
    upsert?: Enumerable<PrecipitacaoUpsertWithWhereUniqueWithoutLeituraInput>
    set?: Enumerable<PrecipitacaoWhereUniqueInput>
    disconnect?: Enumerable<PrecipitacaoWhereUniqueInput>
    delete?: Enumerable<PrecipitacaoWhereUniqueInput>
    connect?: Enumerable<PrecipitacaoWhereUniqueInput>
    update?: Enumerable<PrecipitacaoUpdateWithWhereUniqueWithoutLeituraInput>
    updateMany?: Enumerable<PrecipitacaoUpdateManyWithWhereWithoutLeituraInput>
    deleteMany?: Enumerable<PrecipitacaoScalarWhereInput>
  }

  export type UmidadeSoloUncheckedUpdateManyWithoutLeituraInput = {
    create?: XOR<Enumerable<UmidadeSoloCreateWithoutLeituraInput>, Enumerable<UmidadeSoloUncheckedCreateWithoutLeituraInput>>
    connectOrCreate?: Enumerable<UmidadeSoloCreateOrConnectWithoutLeituraInput>
    upsert?: Enumerable<UmidadeSoloUpsertWithWhereUniqueWithoutLeituraInput>
    set?: Enumerable<UmidadeSoloWhereUniqueInput>
    disconnect?: Enumerable<UmidadeSoloWhereUniqueInput>
    delete?: Enumerable<UmidadeSoloWhereUniqueInput>
    connect?: Enumerable<UmidadeSoloWhereUniqueInput>
    update?: Enumerable<UmidadeSoloUpdateWithWhereUniqueWithoutLeituraInput>
    updateMany?: Enumerable<UmidadeSoloUpdateManyWithWhereWithoutLeituraInput>
    deleteMany?: Enumerable<UmidadeSoloScalarWhereInput>
  }

  export type UmidadeRelativaUncheckedUpdateManyWithoutLeituraInput = {
    create?: XOR<Enumerable<UmidadeRelativaCreateWithoutLeituraInput>, Enumerable<UmidadeRelativaUncheckedCreateWithoutLeituraInput>>
    connectOrCreate?: Enumerable<UmidadeRelativaCreateOrConnectWithoutLeituraInput>
    upsert?: Enumerable<UmidadeRelativaUpsertWithWhereUniqueWithoutLeituraInput>
    set?: Enumerable<UmidadeRelativaWhereUniqueInput>
    disconnect?: Enumerable<UmidadeRelativaWhereUniqueInput>
    delete?: Enumerable<UmidadeRelativaWhereUniqueInput>
    connect?: Enumerable<UmidadeRelativaWhereUniqueInput>
    update?: Enumerable<UmidadeRelativaUpdateWithWhereUniqueWithoutLeituraInput>
    updateMany?: Enumerable<UmidadeRelativaUpdateManyWithWhereWithoutLeituraInput>
    deleteMany?: Enumerable<UmidadeRelativaScalarWhereInput>
  }

  export type LeituraCreateNestedOneWithoutTemperaturaInput = {
    create?: XOR<LeituraCreateWithoutTemperaturaInput, LeituraUncheckedCreateWithoutTemperaturaInput>
    connectOrCreate?: LeituraCreateOrConnectWithoutTemperaturaInput
    connect?: LeituraWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type LeituraUpdateOneRequiredWithoutTemperaturaInput = {
    create?: XOR<LeituraCreateWithoutTemperaturaInput, LeituraUncheckedCreateWithoutTemperaturaInput>
    connectOrCreate?: LeituraCreateOrConnectWithoutTemperaturaInput
    upsert?: LeituraUpsertWithoutTemperaturaInput
    connect?: LeituraWhereUniqueInput
    update?: XOR<LeituraUpdateWithoutTemperaturaInput, LeituraUncheckedUpdateWithoutTemperaturaInput>
  }

  export type LeituraCreateNestedOneWithoutPressaoInput = {
    create?: XOR<LeituraCreateWithoutPressaoInput, LeituraUncheckedCreateWithoutPressaoInput>
    connectOrCreate?: LeituraCreateOrConnectWithoutPressaoInput
    connect?: LeituraWhereUniqueInput
  }

  export type LeituraUpdateOneRequiredWithoutPressaoInput = {
    create?: XOR<LeituraCreateWithoutPressaoInput, LeituraUncheckedCreateWithoutPressaoInput>
    connectOrCreate?: LeituraCreateOrConnectWithoutPressaoInput
    upsert?: LeituraUpsertWithoutPressaoInput
    connect?: LeituraWhereUniqueInput
    update?: XOR<LeituraUpdateWithoutPressaoInput, LeituraUncheckedUpdateWithoutPressaoInput>
  }

  export type LeituraCreateNestedOneWithoutAltitudeInput = {
    create?: XOR<LeituraCreateWithoutAltitudeInput, LeituraUncheckedCreateWithoutAltitudeInput>
    connectOrCreate?: LeituraCreateOrConnectWithoutAltitudeInput
    connect?: LeituraWhereUniqueInput
  }

  export type LeituraUpdateOneRequiredWithoutAltitudeInput = {
    create?: XOR<LeituraCreateWithoutAltitudeInput, LeituraUncheckedCreateWithoutAltitudeInput>
    connectOrCreate?: LeituraCreateOrConnectWithoutAltitudeInput
    upsert?: LeituraUpsertWithoutAltitudeInput
    connect?: LeituraWhereUniqueInput
    update?: XOR<LeituraUpdateWithoutAltitudeInput, LeituraUncheckedUpdateWithoutAltitudeInput>
  }

  export type LeituraCreateNestedOneWithoutVelocidadeVentoInput = {
    create?: XOR<LeituraCreateWithoutVelocidadeVentoInput, LeituraUncheckedCreateWithoutVelocidadeVentoInput>
    connectOrCreate?: LeituraCreateOrConnectWithoutVelocidadeVentoInput
    connect?: LeituraWhereUniqueInput
  }

  export type LeituraUpdateOneRequiredWithoutVelocidadeVentoInput = {
    create?: XOR<LeituraCreateWithoutVelocidadeVentoInput, LeituraUncheckedCreateWithoutVelocidadeVentoInput>
    connectOrCreate?: LeituraCreateOrConnectWithoutVelocidadeVentoInput
    upsert?: LeituraUpsertWithoutVelocidadeVentoInput
    connect?: LeituraWhereUniqueInput
    update?: XOR<LeituraUpdateWithoutVelocidadeVentoInput, LeituraUncheckedUpdateWithoutVelocidadeVentoInput>
  }

  export type LeituraCreateNestedOneWithoutDirecaoVentoInput = {
    create?: XOR<LeituraCreateWithoutDirecaoVentoInput, LeituraUncheckedCreateWithoutDirecaoVentoInput>
    connectOrCreate?: LeituraCreateOrConnectWithoutDirecaoVentoInput
    connect?: LeituraWhereUniqueInput
  }

  export type LeituraUpdateOneRequiredWithoutDirecaoVentoInput = {
    create?: XOR<LeituraCreateWithoutDirecaoVentoInput, LeituraUncheckedCreateWithoutDirecaoVentoInput>
    connectOrCreate?: LeituraCreateOrConnectWithoutDirecaoVentoInput
    upsert?: LeituraUpsertWithoutDirecaoVentoInput
    connect?: LeituraWhereUniqueInput
    update?: XOR<LeituraUpdateWithoutDirecaoVentoInput, LeituraUncheckedUpdateWithoutDirecaoVentoInput>
  }

  export type LeituraCreateNestedOneWithoutPrecipitacaoInput = {
    create?: XOR<LeituraCreateWithoutPrecipitacaoInput, LeituraUncheckedCreateWithoutPrecipitacaoInput>
    connectOrCreate?: LeituraCreateOrConnectWithoutPrecipitacaoInput
    connect?: LeituraWhereUniqueInput
  }

  export type LeituraUpdateOneRequiredWithoutPrecipitacaoInput = {
    create?: XOR<LeituraCreateWithoutPrecipitacaoInput, LeituraUncheckedCreateWithoutPrecipitacaoInput>
    connectOrCreate?: LeituraCreateOrConnectWithoutPrecipitacaoInput
    upsert?: LeituraUpsertWithoutPrecipitacaoInput
    connect?: LeituraWhereUniqueInput
    update?: XOR<LeituraUpdateWithoutPrecipitacaoInput, LeituraUncheckedUpdateWithoutPrecipitacaoInput>
  }

  export type LeituraCreateNestedOneWithoutUmidadeSoloInput = {
    create?: XOR<LeituraCreateWithoutUmidadeSoloInput, LeituraUncheckedCreateWithoutUmidadeSoloInput>
    connectOrCreate?: LeituraCreateOrConnectWithoutUmidadeSoloInput
    connect?: LeituraWhereUniqueInput
  }

  export type LeituraUpdateOneRequiredWithoutUmidadeSoloInput = {
    create?: XOR<LeituraCreateWithoutUmidadeSoloInput, LeituraUncheckedCreateWithoutUmidadeSoloInput>
    connectOrCreate?: LeituraCreateOrConnectWithoutUmidadeSoloInput
    upsert?: LeituraUpsertWithoutUmidadeSoloInput
    connect?: LeituraWhereUniqueInput
    update?: XOR<LeituraUpdateWithoutUmidadeSoloInput, LeituraUncheckedUpdateWithoutUmidadeSoloInput>
  }

  export type LeituraCreateNestedOneWithoutUmidadeRelativaInput = {
    create?: XOR<LeituraCreateWithoutUmidadeRelativaInput, LeituraUncheckedCreateWithoutUmidadeRelativaInput>
    connectOrCreate?: LeituraCreateOrConnectWithoutUmidadeRelativaInput
    connect?: LeituraWhereUniqueInput
  }

  export type LeituraUpdateOneRequiredWithoutUmidadeRelativaInput = {
    create?: XOR<LeituraCreateWithoutUmidadeRelativaInput, LeituraUncheckedCreateWithoutUmidadeRelativaInput>
    connectOrCreate?: LeituraCreateOrConnectWithoutUmidadeRelativaInput
    upsert?: LeituraUpsertWithoutUmidadeRelativaInput
    connect?: LeituraWhereUniqueInput
    update?: XOR<LeituraUpdateWithoutUmidadeRelativaInput, LeituraUncheckedUpdateWithoutUmidadeRelativaInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type TemperaturaCreateWithoutLeituraInput = {
    sensor: string
    valor: number
    unidade: string
    ordemGrandeza: number
  }

  export type TemperaturaUncheckedCreateWithoutLeituraInput = {
    id?: number
    sensor: string
    valor: number
    unidade: string
    ordemGrandeza: number
  }

  export type TemperaturaCreateOrConnectWithoutLeituraInput = {
    where: TemperaturaWhereUniqueInput
    create: XOR<TemperaturaCreateWithoutLeituraInput, TemperaturaUncheckedCreateWithoutLeituraInput>
  }

  export type PressaoCreateWithoutLeituraInput = {
    sensor: string
    valor: number
    unidade: string
    ordemGrandeza: number
  }

  export type PressaoUncheckedCreateWithoutLeituraInput = {
    id?: number
    sensor: string
    valor: number
    unidade: string
    ordemGrandeza: number
  }

  export type PressaoCreateOrConnectWithoutLeituraInput = {
    where: PressaoWhereUniqueInput
    create: XOR<PressaoCreateWithoutLeituraInput, PressaoUncheckedCreateWithoutLeituraInput>
  }

  export type AltitudeCreateWithoutLeituraInput = {
    sensor: string
    valor: number
    unidade: string
    ordemGrandeza: number
  }

  export type AltitudeUncheckedCreateWithoutLeituraInput = {
    id?: number
    sensor: string
    valor: number
    unidade: string
    ordemGrandeza: number
  }

  export type AltitudeCreateOrConnectWithoutLeituraInput = {
    where: AltitudeWhereUniqueInput
    create: XOR<AltitudeCreateWithoutLeituraInput, AltitudeUncheckedCreateWithoutLeituraInput>
  }

  export type VelocidadeVentoCreateWithoutLeituraInput = {
    sensor: string
    media: number
    maximo: number
    unidade: string
    ordemGrandeza: number
  }

  export type VelocidadeVentoUncheckedCreateWithoutLeituraInput = {
    id?: number
    sensor: string
    media: number
    maximo: number
    unidade: string
    ordemGrandeza: number
  }

  export type VelocidadeVentoCreateOrConnectWithoutLeituraInput = {
    where: VelocidadeVentoWhereUniqueInput
    create: XOR<VelocidadeVentoCreateWithoutLeituraInput, VelocidadeVentoUncheckedCreateWithoutLeituraInput>
  }

  export type DirecaoVentoCreateWithoutLeituraInput = {
    sensor: string
    valor: number
    unidade: string
    ordemGrandeza: number
  }

  export type DirecaoVentoUncheckedCreateWithoutLeituraInput = {
    id?: number
    sensor: string
    valor: number
    unidade: string
    ordemGrandeza: number
  }

  export type DirecaoVentoCreateOrConnectWithoutLeituraInput = {
    where: DirecaoVentoWhereUniqueInput
    create: XOR<DirecaoVentoCreateWithoutLeituraInput, DirecaoVentoUncheckedCreateWithoutLeituraInput>
  }

  export type PrecipitacaoCreateWithoutLeituraInput = {
    sensor: string
    valor: number
    unidade: string
    ordemGrandeza: number
  }

  export type PrecipitacaoUncheckedCreateWithoutLeituraInput = {
    id?: number
    sensor: string
    valor: number
    unidade: string
    ordemGrandeza: number
  }

  export type PrecipitacaoCreateOrConnectWithoutLeituraInput = {
    where: PrecipitacaoWhereUniqueInput
    create: XOR<PrecipitacaoCreateWithoutLeituraInput, PrecipitacaoUncheckedCreateWithoutLeituraInput>
  }

  export type UmidadeSoloCreateWithoutLeituraInput = {
    sensor: string
    valor: number
    unidade: string
    ordemGrandeza: number
  }

  export type UmidadeSoloUncheckedCreateWithoutLeituraInput = {
    id?: number
    sensor: string
    valor: number
    unidade: string
    ordemGrandeza: number
  }

  export type UmidadeSoloCreateOrConnectWithoutLeituraInput = {
    where: UmidadeSoloWhereUniqueInput
    create: XOR<UmidadeSoloCreateWithoutLeituraInput, UmidadeSoloUncheckedCreateWithoutLeituraInput>
  }

  export type UmidadeRelativaCreateWithoutLeituraInput = {
    sensor: string
    valor: number
    unidade: string
    ordemGrandeza: number
  }

  export type UmidadeRelativaUncheckedCreateWithoutLeituraInput = {
    id?: number
    sensor: string
    valor: number
    unidade: string
    ordemGrandeza: number
  }

  export type UmidadeRelativaCreateOrConnectWithoutLeituraInput = {
    where: UmidadeRelativaWhereUniqueInput
    create: XOR<UmidadeRelativaCreateWithoutLeituraInput, UmidadeRelativaUncheckedCreateWithoutLeituraInput>
  }

  export type TemperaturaUpsertWithWhereUniqueWithoutLeituraInput = {
    where: TemperaturaWhereUniqueInput
    update: XOR<TemperaturaUpdateWithoutLeituraInput, TemperaturaUncheckedUpdateWithoutLeituraInput>
    create: XOR<TemperaturaCreateWithoutLeituraInput, TemperaturaUncheckedCreateWithoutLeituraInput>
  }

  export type TemperaturaUpdateWithWhereUniqueWithoutLeituraInput = {
    where: TemperaturaWhereUniqueInput
    data: XOR<TemperaturaUpdateWithoutLeituraInput, TemperaturaUncheckedUpdateWithoutLeituraInput>
  }

  export type TemperaturaUpdateManyWithWhereWithoutLeituraInput = {
    where: TemperaturaScalarWhereInput
    data: XOR<TemperaturaUpdateManyMutationInput, TemperaturaUncheckedUpdateManyWithoutTemperaturaInput>
  }

  export type TemperaturaScalarWhereInput = {
    AND?: Enumerable<TemperaturaScalarWhereInput>
    OR?: Enumerable<TemperaturaScalarWhereInput>
    NOT?: Enumerable<TemperaturaScalarWhereInput>
    id?: IntFilter | number
    sensor?: StringFilter | string
    valor?: IntFilter | number
    unidade?: StringFilter | string
    ordemGrandeza?: IntFilter | number
    leituraId?: IntFilter | number
  }

  export type PressaoUpsertWithWhereUniqueWithoutLeituraInput = {
    where: PressaoWhereUniqueInput
    update: XOR<PressaoUpdateWithoutLeituraInput, PressaoUncheckedUpdateWithoutLeituraInput>
    create: XOR<PressaoCreateWithoutLeituraInput, PressaoUncheckedCreateWithoutLeituraInput>
  }

  export type PressaoUpdateWithWhereUniqueWithoutLeituraInput = {
    where: PressaoWhereUniqueInput
    data: XOR<PressaoUpdateWithoutLeituraInput, PressaoUncheckedUpdateWithoutLeituraInput>
  }

  export type PressaoUpdateManyWithWhereWithoutLeituraInput = {
    where: PressaoScalarWhereInput
    data: XOR<PressaoUpdateManyMutationInput, PressaoUncheckedUpdateManyWithoutPressaoInput>
  }

  export type PressaoScalarWhereInput = {
    AND?: Enumerable<PressaoScalarWhereInput>
    OR?: Enumerable<PressaoScalarWhereInput>
    NOT?: Enumerable<PressaoScalarWhereInput>
    id?: IntFilter | number
    sensor?: StringFilter | string
    valor?: IntFilter | number
    unidade?: StringFilter | string
    ordemGrandeza?: IntFilter | number
    leituraId?: IntFilter | number
  }

  export type AltitudeUpsertWithWhereUniqueWithoutLeituraInput = {
    where: AltitudeWhereUniqueInput
    update: XOR<AltitudeUpdateWithoutLeituraInput, AltitudeUncheckedUpdateWithoutLeituraInput>
    create: XOR<AltitudeCreateWithoutLeituraInput, AltitudeUncheckedCreateWithoutLeituraInput>
  }

  export type AltitudeUpdateWithWhereUniqueWithoutLeituraInput = {
    where: AltitudeWhereUniqueInput
    data: XOR<AltitudeUpdateWithoutLeituraInput, AltitudeUncheckedUpdateWithoutLeituraInput>
  }

  export type AltitudeUpdateManyWithWhereWithoutLeituraInput = {
    where: AltitudeScalarWhereInput
    data: XOR<AltitudeUpdateManyMutationInput, AltitudeUncheckedUpdateManyWithoutAltitudeInput>
  }

  export type AltitudeScalarWhereInput = {
    AND?: Enumerable<AltitudeScalarWhereInput>
    OR?: Enumerable<AltitudeScalarWhereInput>
    NOT?: Enumerable<AltitudeScalarWhereInput>
    id?: IntFilter | number
    sensor?: StringFilter | string
    valor?: IntFilter | number
    unidade?: StringFilter | string
    ordemGrandeza?: IntFilter | number
    leituraId?: IntFilter | number
  }

  export type VelocidadeVentoUpsertWithWhereUniqueWithoutLeituraInput = {
    where: VelocidadeVentoWhereUniqueInput
    update: XOR<VelocidadeVentoUpdateWithoutLeituraInput, VelocidadeVentoUncheckedUpdateWithoutLeituraInput>
    create: XOR<VelocidadeVentoCreateWithoutLeituraInput, VelocidadeVentoUncheckedCreateWithoutLeituraInput>
  }

  export type VelocidadeVentoUpdateWithWhereUniqueWithoutLeituraInput = {
    where: VelocidadeVentoWhereUniqueInput
    data: XOR<VelocidadeVentoUpdateWithoutLeituraInput, VelocidadeVentoUncheckedUpdateWithoutLeituraInput>
  }

  export type VelocidadeVentoUpdateManyWithWhereWithoutLeituraInput = {
    where: VelocidadeVentoScalarWhereInput
    data: XOR<VelocidadeVentoUpdateManyMutationInput, VelocidadeVentoUncheckedUpdateManyWithoutVelocidadeVentoInput>
  }

  export type VelocidadeVentoScalarWhereInput = {
    AND?: Enumerable<VelocidadeVentoScalarWhereInput>
    OR?: Enumerable<VelocidadeVentoScalarWhereInput>
    NOT?: Enumerable<VelocidadeVentoScalarWhereInput>
    id?: IntFilter | number
    sensor?: StringFilter | string
    media?: IntFilter | number
    maximo?: IntFilter | number
    unidade?: StringFilter | string
    ordemGrandeza?: IntFilter | number
    leituraId?: IntFilter | number
  }

  export type DirecaoVentoUpsertWithWhereUniqueWithoutLeituraInput = {
    where: DirecaoVentoWhereUniqueInput
    update: XOR<DirecaoVentoUpdateWithoutLeituraInput, DirecaoVentoUncheckedUpdateWithoutLeituraInput>
    create: XOR<DirecaoVentoCreateWithoutLeituraInput, DirecaoVentoUncheckedCreateWithoutLeituraInput>
  }

  export type DirecaoVentoUpdateWithWhereUniqueWithoutLeituraInput = {
    where: DirecaoVentoWhereUniqueInput
    data: XOR<DirecaoVentoUpdateWithoutLeituraInput, DirecaoVentoUncheckedUpdateWithoutLeituraInput>
  }

  export type DirecaoVentoUpdateManyWithWhereWithoutLeituraInput = {
    where: DirecaoVentoScalarWhereInput
    data: XOR<DirecaoVentoUpdateManyMutationInput, DirecaoVentoUncheckedUpdateManyWithoutDirecaoVentoInput>
  }

  export type DirecaoVentoScalarWhereInput = {
    AND?: Enumerable<DirecaoVentoScalarWhereInput>
    OR?: Enumerable<DirecaoVentoScalarWhereInput>
    NOT?: Enumerable<DirecaoVentoScalarWhereInput>
    id?: IntFilter | number
    sensor?: StringFilter | string
    valor?: IntFilter | number
    unidade?: StringFilter | string
    ordemGrandeza?: IntFilter | number
    leituraId?: IntFilter | number
  }

  export type PrecipitacaoUpsertWithWhereUniqueWithoutLeituraInput = {
    where: PrecipitacaoWhereUniqueInput
    update: XOR<PrecipitacaoUpdateWithoutLeituraInput, PrecipitacaoUncheckedUpdateWithoutLeituraInput>
    create: XOR<PrecipitacaoCreateWithoutLeituraInput, PrecipitacaoUncheckedCreateWithoutLeituraInput>
  }

  export type PrecipitacaoUpdateWithWhereUniqueWithoutLeituraInput = {
    where: PrecipitacaoWhereUniqueInput
    data: XOR<PrecipitacaoUpdateWithoutLeituraInput, PrecipitacaoUncheckedUpdateWithoutLeituraInput>
  }

  export type PrecipitacaoUpdateManyWithWhereWithoutLeituraInput = {
    where: PrecipitacaoScalarWhereInput
    data: XOR<PrecipitacaoUpdateManyMutationInput, PrecipitacaoUncheckedUpdateManyWithoutPrecipitacaoInput>
  }

  export type PrecipitacaoScalarWhereInput = {
    AND?: Enumerable<PrecipitacaoScalarWhereInput>
    OR?: Enumerable<PrecipitacaoScalarWhereInput>
    NOT?: Enumerable<PrecipitacaoScalarWhereInput>
    id?: IntFilter | number
    sensor?: StringFilter | string
    valor?: IntFilter | number
    unidade?: StringFilter | string
    ordemGrandeza?: IntFilter | number
    leituraId?: IntFilter | number
  }

  export type UmidadeSoloUpsertWithWhereUniqueWithoutLeituraInput = {
    where: UmidadeSoloWhereUniqueInput
    update: XOR<UmidadeSoloUpdateWithoutLeituraInput, UmidadeSoloUncheckedUpdateWithoutLeituraInput>
    create: XOR<UmidadeSoloCreateWithoutLeituraInput, UmidadeSoloUncheckedCreateWithoutLeituraInput>
  }

  export type UmidadeSoloUpdateWithWhereUniqueWithoutLeituraInput = {
    where: UmidadeSoloWhereUniqueInput
    data: XOR<UmidadeSoloUpdateWithoutLeituraInput, UmidadeSoloUncheckedUpdateWithoutLeituraInput>
  }

  export type UmidadeSoloUpdateManyWithWhereWithoutLeituraInput = {
    where: UmidadeSoloScalarWhereInput
    data: XOR<UmidadeSoloUpdateManyMutationInput, UmidadeSoloUncheckedUpdateManyWithoutUmidadeSoloInput>
  }

  export type UmidadeSoloScalarWhereInput = {
    AND?: Enumerable<UmidadeSoloScalarWhereInput>
    OR?: Enumerable<UmidadeSoloScalarWhereInput>
    NOT?: Enumerable<UmidadeSoloScalarWhereInput>
    id?: IntFilter | number
    sensor?: StringFilter | string
    valor?: IntFilter | number
    unidade?: StringFilter | string
    ordemGrandeza?: IntFilter | number
    leituraId?: IntFilter | number
  }

  export type UmidadeRelativaUpsertWithWhereUniqueWithoutLeituraInput = {
    where: UmidadeRelativaWhereUniqueInput
    update: XOR<UmidadeRelativaUpdateWithoutLeituraInput, UmidadeRelativaUncheckedUpdateWithoutLeituraInput>
    create: XOR<UmidadeRelativaCreateWithoutLeituraInput, UmidadeRelativaUncheckedCreateWithoutLeituraInput>
  }

  export type UmidadeRelativaUpdateWithWhereUniqueWithoutLeituraInput = {
    where: UmidadeRelativaWhereUniqueInput
    data: XOR<UmidadeRelativaUpdateWithoutLeituraInput, UmidadeRelativaUncheckedUpdateWithoutLeituraInput>
  }

  export type UmidadeRelativaUpdateManyWithWhereWithoutLeituraInput = {
    where: UmidadeRelativaScalarWhereInput
    data: XOR<UmidadeRelativaUpdateManyMutationInput, UmidadeRelativaUncheckedUpdateManyWithoutUmidadeRelativaInput>
  }

  export type UmidadeRelativaScalarWhereInput = {
    AND?: Enumerable<UmidadeRelativaScalarWhereInput>
    OR?: Enumerable<UmidadeRelativaScalarWhereInput>
    NOT?: Enumerable<UmidadeRelativaScalarWhereInput>
    id?: IntFilter | number
    sensor?: StringFilter | string
    valor?: IntFilter | number
    unidade?: StringFilter | string
    ordemGrandeza?: IntFilter | number
    leituraId?: IntFilter | number
  }

  export type LeituraCreateWithoutTemperaturaInput = {
    createdAt?: Date | string
    Pressao?: PressaoCreateNestedManyWithoutLeituraInput
    Altitude?: AltitudeCreateNestedManyWithoutLeituraInput
    VelocidadeVento?: VelocidadeVentoCreateNestedManyWithoutLeituraInput
    DirecaoVento?: DirecaoVentoCreateNestedManyWithoutLeituraInput
    Precipitacao?: PrecipitacaoCreateNestedManyWithoutLeituraInput
    UmidadeSolo?: UmidadeSoloCreateNestedManyWithoutLeituraInput
    UmidadeRelativa?: UmidadeRelativaCreateNestedManyWithoutLeituraInput
  }

  export type LeituraUncheckedCreateWithoutTemperaturaInput = {
    id?: number
    createdAt?: Date | string
    Pressao?: PressaoUncheckedCreateNestedManyWithoutLeituraInput
    Altitude?: AltitudeUncheckedCreateNestedManyWithoutLeituraInput
    VelocidadeVento?: VelocidadeVentoUncheckedCreateNestedManyWithoutLeituraInput
    DirecaoVento?: DirecaoVentoUncheckedCreateNestedManyWithoutLeituraInput
    Precipitacao?: PrecipitacaoUncheckedCreateNestedManyWithoutLeituraInput
    UmidadeSolo?: UmidadeSoloUncheckedCreateNestedManyWithoutLeituraInput
    UmidadeRelativa?: UmidadeRelativaUncheckedCreateNestedManyWithoutLeituraInput
  }

  export type LeituraCreateOrConnectWithoutTemperaturaInput = {
    where: LeituraWhereUniqueInput
    create: XOR<LeituraCreateWithoutTemperaturaInput, LeituraUncheckedCreateWithoutTemperaturaInput>
  }

  export type LeituraUpsertWithoutTemperaturaInput = {
    update: XOR<LeituraUpdateWithoutTemperaturaInput, LeituraUncheckedUpdateWithoutTemperaturaInput>
    create: XOR<LeituraCreateWithoutTemperaturaInput, LeituraUncheckedCreateWithoutTemperaturaInput>
  }

  export type LeituraUpdateWithoutTemperaturaInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Pressao?: PressaoUpdateManyWithoutLeituraInput
    Altitude?: AltitudeUpdateManyWithoutLeituraInput
    VelocidadeVento?: VelocidadeVentoUpdateManyWithoutLeituraInput
    DirecaoVento?: DirecaoVentoUpdateManyWithoutLeituraInput
    Precipitacao?: PrecipitacaoUpdateManyWithoutLeituraInput
    UmidadeSolo?: UmidadeSoloUpdateManyWithoutLeituraInput
    UmidadeRelativa?: UmidadeRelativaUpdateManyWithoutLeituraInput
  }

  export type LeituraUncheckedUpdateWithoutTemperaturaInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Pressao?: PressaoUncheckedUpdateManyWithoutLeituraInput
    Altitude?: AltitudeUncheckedUpdateManyWithoutLeituraInput
    VelocidadeVento?: VelocidadeVentoUncheckedUpdateManyWithoutLeituraInput
    DirecaoVento?: DirecaoVentoUncheckedUpdateManyWithoutLeituraInput
    Precipitacao?: PrecipitacaoUncheckedUpdateManyWithoutLeituraInput
    UmidadeSolo?: UmidadeSoloUncheckedUpdateManyWithoutLeituraInput
    UmidadeRelativa?: UmidadeRelativaUncheckedUpdateManyWithoutLeituraInput
  }

  export type LeituraCreateWithoutPressaoInput = {
    createdAt?: Date | string
    Temperatura?: TemperaturaCreateNestedManyWithoutLeituraInput
    Altitude?: AltitudeCreateNestedManyWithoutLeituraInput
    VelocidadeVento?: VelocidadeVentoCreateNestedManyWithoutLeituraInput
    DirecaoVento?: DirecaoVentoCreateNestedManyWithoutLeituraInput
    Precipitacao?: PrecipitacaoCreateNestedManyWithoutLeituraInput
    UmidadeSolo?: UmidadeSoloCreateNestedManyWithoutLeituraInput
    UmidadeRelativa?: UmidadeRelativaCreateNestedManyWithoutLeituraInput
  }

  export type LeituraUncheckedCreateWithoutPressaoInput = {
    id?: number
    createdAt?: Date | string
    Temperatura?: TemperaturaUncheckedCreateNestedManyWithoutLeituraInput
    Altitude?: AltitudeUncheckedCreateNestedManyWithoutLeituraInput
    VelocidadeVento?: VelocidadeVentoUncheckedCreateNestedManyWithoutLeituraInput
    DirecaoVento?: DirecaoVentoUncheckedCreateNestedManyWithoutLeituraInput
    Precipitacao?: PrecipitacaoUncheckedCreateNestedManyWithoutLeituraInput
    UmidadeSolo?: UmidadeSoloUncheckedCreateNestedManyWithoutLeituraInput
    UmidadeRelativa?: UmidadeRelativaUncheckedCreateNestedManyWithoutLeituraInput
  }

  export type LeituraCreateOrConnectWithoutPressaoInput = {
    where: LeituraWhereUniqueInput
    create: XOR<LeituraCreateWithoutPressaoInput, LeituraUncheckedCreateWithoutPressaoInput>
  }

  export type LeituraUpsertWithoutPressaoInput = {
    update: XOR<LeituraUpdateWithoutPressaoInput, LeituraUncheckedUpdateWithoutPressaoInput>
    create: XOR<LeituraCreateWithoutPressaoInput, LeituraUncheckedCreateWithoutPressaoInput>
  }

  export type LeituraUpdateWithoutPressaoInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Temperatura?: TemperaturaUpdateManyWithoutLeituraInput
    Altitude?: AltitudeUpdateManyWithoutLeituraInput
    VelocidadeVento?: VelocidadeVentoUpdateManyWithoutLeituraInput
    DirecaoVento?: DirecaoVentoUpdateManyWithoutLeituraInput
    Precipitacao?: PrecipitacaoUpdateManyWithoutLeituraInput
    UmidadeSolo?: UmidadeSoloUpdateManyWithoutLeituraInput
    UmidadeRelativa?: UmidadeRelativaUpdateManyWithoutLeituraInput
  }

  export type LeituraUncheckedUpdateWithoutPressaoInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Temperatura?: TemperaturaUncheckedUpdateManyWithoutLeituraInput
    Altitude?: AltitudeUncheckedUpdateManyWithoutLeituraInput
    VelocidadeVento?: VelocidadeVentoUncheckedUpdateManyWithoutLeituraInput
    DirecaoVento?: DirecaoVentoUncheckedUpdateManyWithoutLeituraInput
    Precipitacao?: PrecipitacaoUncheckedUpdateManyWithoutLeituraInput
    UmidadeSolo?: UmidadeSoloUncheckedUpdateManyWithoutLeituraInput
    UmidadeRelativa?: UmidadeRelativaUncheckedUpdateManyWithoutLeituraInput
  }

  export type LeituraCreateWithoutAltitudeInput = {
    createdAt?: Date | string
    Temperatura?: TemperaturaCreateNestedManyWithoutLeituraInput
    Pressao?: PressaoCreateNestedManyWithoutLeituraInput
    VelocidadeVento?: VelocidadeVentoCreateNestedManyWithoutLeituraInput
    DirecaoVento?: DirecaoVentoCreateNestedManyWithoutLeituraInput
    Precipitacao?: PrecipitacaoCreateNestedManyWithoutLeituraInput
    UmidadeSolo?: UmidadeSoloCreateNestedManyWithoutLeituraInput
    UmidadeRelativa?: UmidadeRelativaCreateNestedManyWithoutLeituraInput
  }

  export type LeituraUncheckedCreateWithoutAltitudeInput = {
    id?: number
    createdAt?: Date | string
    Temperatura?: TemperaturaUncheckedCreateNestedManyWithoutLeituraInput
    Pressao?: PressaoUncheckedCreateNestedManyWithoutLeituraInput
    VelocidadeVento?: VelocidadeVentoUncheckedCreateNestedManyWithoutLeituraInput
    DirecaoVento?: DirecaoVentoUncheckedCreateNestedManyWithoutLeituraInput
    Precipitacao?: PrecipitacaoUncheckedCreateNestedManyWithoutLeituraInput
    UmidadeSolo?: UmidadeSoloUncheckedCreateNestedManyWithoutLeituraInput
    UmidadeRelativa?: UmidadeRelativaUncheckedCreateNestedManyWithoutLeituraInput
  }

  export type LeituraCreateOrConnectWithoutAltitudeInput = {
    where: LeituraWhereUniqueInput
    create: XOR<LeituraCreateWithoutAltitudeInput, LeituraUncheckedCreateWithoutAltitudeInput>
  }

  export type LeituraUpsertWithoutAltitudeInput = {
    update: XOR<LeituraUpdateWithoutAltitudeInput, LeituraUncheckedUpdateWithoutAltitudeInput>
    create: XOR<LeituraCreateWithoutAltitudeInput, LeituraUncheckedCreateWithoutAltitudeInput>
  }

  export type LeituraUpdateWithoutAltitudeInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Temperatura?: TemperaturaUpdateManyWithoutLeituraInput
    Pressao?: PressaoUpdateManyWithoutLeituraInput
    VelocidadeVento?: VelocidadeVentoUpdateManyWithoutLeituraInput
    DirecaoVento?: DirecaoVentoUpdateManyWithoutLeituraInput
    Precipitacao?: PrecipitacaoUpdateManyWithoutLeituraInput
    UmidadeSolo?: UmidadeSoloUpdateManyWithoutLeituraInput
    UmidadeRelativa?: UmidadeRelativaUpdateManyWithoutLeituraInput
  }

  export type LeituraUncheckedUpdateWithoutAltitudeInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Temperatura?: TemperaturaUncheckedUpdateManyWithoutLeituraInput
    Pressao?: PressaoUncheckedUpdateManyWithoutLeituraInput
    VelocidadeVento?: VelocidadeVentoUncheckedUpdateManyWithoutLeituraInput
    DirecaoVento?: DirecaoVentoUncheckedUpdateManyWithoutLeituraInput
    Precipitacao?: PrecipitacaoUncheckedUpdateManyWithoutLeituraInput
    UmidadeSolo?: UmidadeSoloUncheckedUpdateManyWithoutLeituraInput
    UmidadeRelativa?: UmidadeRelativaUncheckedUpdateManyWithoutLeituraInput
  }

  export type LeituraCreateWithoutVelocidadeVentoInput = {
    createdAt?: Date | string
    Temperatura?: TemperaturaCreateNestedManyWithoutLeituraInput
    Pressao?: PressaoCreateNestedManyWithoutLeituraInput
    Altitude?: AltitudeCreateNestedManyWithoutLeituraInput
    DirecaoVento?: DirecaoVentoCreateNestedManyWithoutLeituraInput
    Precipitacao?: PrecipitacaoCreateNestedManyWithoutLeituraInput
    UmidadeSolo?: UmidadeSoloCreateNestedManyWithoutLeituraInput
    UmidadeRelativa?: UmidadeRelativaCreateNestedManyWithoutLeituraInput
  }

  export type LeituraUncheckedCreateWithoutVelocidadeVentoInput = {
    id?: number
    createdAt?: Date | string
    Temperatura?: TemperaturaUncheckedCreateNestedManyWithoutLeituraInput
    Pressao?: PressaoUncheckedCreateNestedManyWithoutLeituraInput
    Altitude?: AltitudeUncheckedCreateNestedManyWithoutLeituraInput
    DirecaoVento?: DirecaoVentoUncheckedCreateNestedManyWithoutLeituraInput
    Precipitacao?: PrecipitacaoUncheckedCreateNestedManyWithoutLeituraInput
    UmidadeSolo?: UmidadeSoloUncheckedCreateNestedManyWithoutLeituraInput
    UmidadeRelativa?: UmidadeRelativaUncheckedCreateNestedManyWithoutLeituraInput
  }

  export type LeituraCreateOrConnectWithoutVelocidadeVentoInput = {
    where: LeituraWhereUniqueInput
    create: XOR<LeituraCreateWithoutVelocidadeVentoInput, LeituraUncheckedCreateWithoutVelocidadeVentoInput>
  }

  export type LeituraUpsertWithoutVelocidadeVentoInput = {
    update: XOR<LeituraUpdateWithoutVelocidadeVentoInput, LeituraUncheckedUpdateWithoutVelocidadeVentoInput>
    create: XOR<LeituraCreateWithoutVelocidadeVentoInput, LeituraUncheckedCreateWithoutVelocidadeVentoInput>
  }

  export type LeituraUpdateWithoutVelocidadeVentoInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Temperatura?: TemperaturaUpdateManyWithoutLeituraInput
    Pressao?: PressaoUpdateManyWithoutLeituraInput
    Altitude?: AltitudeUpdateManyWithoutLeituraInput
    DirecaoVento?: DirecaoVentoUpdateManyWithoutLeituraInput
    Precipitacao?: PrecipitacaoUpdateManyWithoutLeituraInput
    UmidadeSolo?: UmidadeSoloUpdateManyWithoutLeituraInput
    UmidadeRelativa?: UmidadeRelativaUpdateManyWithoutLeituraInput
  }

  export type LeituraUncheckedUpdateWithoutVelocidadeVentoInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Temperatura?: TemperaturaUncheckedUpdateManyWithoutLeituraInput
    Pressao?: PressaoUncheckedUpdateManyWithoutLeituraInput
    Altitude?: AltitudeUncheckedUpdateManyWithoutLeituraInput
    DirecaoVento?: DirecaoVentoUncheckedUpdateManyWithoutLeituraInput
    Precipitacao?: PrecipitacaoUncheckedUpdateManyWithoutLeituraInput
    UmidadeSolo?: UmidadeSoloUncheckedUpdateManyWithoutLeituraInput
    UmidadeRelativa?: UmidadeRelativaUncheckedUpdateManyWithoutLeituraInput
  }

  export type LeituraCreateWithoutDirecaoVentoInput = {
    createdAt?: Date | string
    Temperatura?: TemperaturaCreateNestedManyWithoutLeituraInput
    Pressao?: PressaoCreateNestedManyWithoutLeituraInput
    Altitude?: AltitudeCreateNestedManyWithoutLeituraInput
    VelocidadeVento?: VelocidadeVentoCreateNestedManyWithoutLeituraInput
    Precipitacao?: PrecipitacaoCreateNestedManyWithoutLeituraInput
    UmidadeSolo?: UmidadeSoloCreateNestedManyWithoutLeituraInput
    UmidadeRelativa?: UmidadeRelativaCreateNestedManyWithoutLeituraInput
  }

  export type LeituraUncheckedCreateWithoutDirecaoVentoInput = {
    id?: number
    createdAt?: Date | string
    Temperatura?: TemperaturaUncheckedCreateNestedManyWithoutLeituraInput
    Pressao?: PressaoUncheckedCreateNestedManyWithoutLeituraInput
    Altitude?: AltitudeUncheckedCreateNestedManyWithoutLeituraInput
    VelocidadeVento?: VelocidadeVentoUncheckedCreateNestedManyWithoutLeituraInput
    Precipitacao?: PrecipitacaoUncheckedCreateNestedManyWithoutLeituraInput
    UmidadeSolo?: UmidadeSoloUncheckedCreateNestedManyWithoutLeituraInput
    UmidadeRelativa?: UmidadeRelativaUncheckedCreateNestedManyWithoutLeituraInput
  }

  export type LeituraCreateOrConnectWithoutDirecaoVentoInput = {
    where: LeituraWhereUniqueInput
    create: XOR<LeituraCreateWithoutDirecaoVentoInput, LeituraUncheckedCreateWithoutDirecaoVentoInput>
  }

  export type LeituraUpsertWithoutDirecaoVentoInput = {
    update: XOR<LeituraUpdateWithoutDirecaoVentoInput, LeituraUncheckedUpdateWithoutDirecaoVentoInput>
    create: XOR<LeituraCreateWithoutDirecaoVentoInput, LeituraUncheckedCreateWithoutDirecaoVentoInput>
  }

  export type LeituraUpdateWithoutDirecaoVentoInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Temperatura?: TemperaturaUpdateManyWithoutLeituraInput
    Pressao?: PressaoUpdateManyWithoutLeituraInput
    Altitude?: AltitudeUpdateManyWithoutLeituraInput
    VelocidadeVento?: VelocidadeVentoUpdateManyWithoutLeituraInput
    Precipitacao?: PrecipitacaoUpdateManyWithoutLeituraInput
    UmidadeSolo?: UmidadeSoloUpdateManyWithoutLeituraInput
    UmidadeRelativa?: UmidadeRelativaUpdateManyWithoutLeituraInput
  }

  export type LeituraUncheckedUpdateWithoutDirecaoVentoInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Temperatura?: TemperaturaUncheckedUpdateManyWithoutLeituraInput
    Pressao?: PressaoUncheckedUpdateManyWithoutLeituraInput
    Altitude?: AltitudeUncheckedUpdateManyWithoutLeituraInput
    VelocidadeVento?: VelocidadeVentoUncheckedUpdateManyWithoutLeituraInput
    Precipitacao?: PrecipitacaoUncheckedUpdateManyWithoutLeituraInput
    UmidadeSolo?: UmidadeSoloUncheckedUpdateManyWithoutLeituraInput
    UmidadeRelativa?: UmidadeRelativaUncheckedUpdateManyWithoutLeituraInput
  }

  export type LeituraCreateWithoutPrecipitacaoInput = {
    createdAt?: Date | string
    Temperatura?: TemperaturaCreateNestedManyWithoutLeituraInput
    Pressao?: PressaoCreateNestedManyWithoutLeituraInput
    Altitude?: AltitudeCreateNestedManyWithoutLeituraInput
    VelocidadeVento?: VelocidadeVentoCreateNestedManyWithoutLeituraInput
    DirecaoVento?: DirecaoVentoCreateNestedManyWithoutLeituraInput
    UmidadeSolo?: UmidadeSoloCreateNestedManyWithoutLeituraInput
    UmidadeRelativa?: UmidadeRelativaCreateNestedManyWithoutLeituraInput
  }

  export type LeituraUncheckedCreateWithoutPrecipitacaoInput = {
    id?: number
    createdAt?: Date | string
    Temperatura?: TemperaturaUncheckedCreateNestedManyWithoutLeituraInput
    Pressao?: PressaoUncheckedCreateNestedManyWithoutLeituraInput
    Altitude?: AltitudeUncheckedCreateNestedManyWithoutLeituraInput
    VelocidadeVento?: VelocidadeVentoUncheckedCreateNestedManyWithoutLeituraInput
    DirecaoVento?: DirecaoVentoUncheckedCreateNestedManyWithoutLeituraInput
    UmidadeSolo?: UmidadeSoloUncheckedCreateNestedManyWithoutLeituraInput
    UmidadeRelativa?: UmidadeRelativaUncheckedCreateNestedManyWithoutLeituraInput
  }

  export type LeituraCreateOrConnectWithoutPrecipitacaoInput = {
    where: LeituraWhereUniqueInput
    create: XOR<LeituraCreateWithoutPrecipitacaoInput, LeituraUncheckedCreateWithoutPrecipitacaoInput>
  }

  export type LeituraUpsertWithoutPrecipitacaoInput = {
    update: XOR<LeituraUpdateWithoutPrecipitacaoInput, LeituraUncheckedUpdateWithoutPrecipitacaoInput>
    create: XOR<LeituraCreateWithoutPrecipitacaoInput, LeituraUncheckedCreateWithoutPrecipitacaoInput>
  }

  export type LeituraUpdateWithoutPrecipitacaoInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Temperatura?: TemperaturaUpdateManyWithoutLeituraInput
    Pressao?: PressaoUpdateManyWithoutLeituraInput
    Altitude?: AltitudeUpdateManyWithoutLeituraInput
    VelocidadeVento?: VelocidadeVentoUpdateManyWithoutLeituraInput
    DirecaoVento?: DirecaoVentoUpdateManyWithoutLeituraInput
    UmidadeSolo?: UmidadeSoloUpdateManyWithoutLeituraInput
    UmidadeRelativa?: UmidadeRelativaUpdateManyWithoutLeituraInput
  }

  export type LeituraUncheckedUpdateWithoutPrecipitacaoInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Temperatura?: TemperaturaUncheckedUpdateManyWithoutLeituraInput
    Pressao?: PressaoUncheckedUpdateManyWithoutLeituraInput
    Altitude?: AltitudeUncheckedUpdateManyWithoutLeituraInput
    VelocidadeVento?: VelocidadeVentoUncheckedUpdateManyWithoutLeituraInput
    DirecaoVento?: DirecaoVentoUncheckedUpdateManyWithoutLeituraInput
    UmidadeSolo?: UmidadeSoloUncheckedUpdateManyWithoutLeituraInput
    UmidadeRelativa?: UmidadeRelativaUncheckedUpdateManyWithoutLeituraInput
  }

  export type LeituraCreateWithoutUmidadeSoloInput = {
    createdAt?: Date | string
    Temperatura?: TemperaturaCreateNestedManyWithoutLeituraInput
    Pressao?: PressaoCreateNestedManyWithoutLeituraInput
    Altitude?: AltitudeCreateNestedManyWithoutLeituraInput
    VelocidadeVento?: VelocidadeVentoCreateNestedManyWithoutLeituraInput
    DirecaoVento?: DirecaoVentoCreateNestedManyWithoutLeituraInput
    Precipitacao?: PrecipitacaoCreateNestedManyWithoutLeituraInput
    UmidadeRelativa?: UmidadeRelativaCreateNestedManyWithoutLeituraInput
  }

  export type LeituraUncheckedCreateWithoutUmidadeSoloInput = {
    id?: number
    createdAt?: Date | string
    Temperatura?: TemperaturaUncheckedCreateNestedManyWithoutLeituraInput
    Pressao?: PressaoUncheckedCreateNestedManyWithoutLeituraInput
    Altitude?: AltitudeUncheckedCreateNestedManyWithoutLeituraInput
    VelocidadeVento?: VelocidadeVentoUncheckedCreateNestedManyWithoutLeituraInput
    DirecaoVento?: DirecaoVentoUncheckedCreateNestedManyWithoutLeituraInput
    Precipitacao?: PrecipitacaoUncheckedCreateNestedManyWithoutLeituraInput
    UmidadeRelativa?: UmidadeRelativaUncheckedCreateNestedManyWithoutLeituraInput
  }

  export type LeituraCreateOrConnectWithoutUmidadeSoloInput = {
    where: LeituraWhereUniqueInput
    create: XOR<LeituraCreateWithoutUmidadeSoloInput, LeituraUncheckedCreateWithoutUmidadeSoloInput>
  }

  export type LeituraUpsertWithoutUmidadeSoloInput = {
    update: XOR<LeituraUpdateWithoutUmidadeSoloInput, LeituraUncheckedUpdateWithoutUmidadeSoloInput>
    create: XOR<LeituraCreateWithoutUmidadeSoloInput, LeituraUncheckedCreateWithoutUmidadeSoloInput>
  }

  export type LeituraUpdateWithoutUmidadeSoloInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Temperatura?: TemperaturaUpdateManyWithoutLeituraInput
    Pressao?: PressaoUpdateManyWithoutLeituraInput
    Altitude?: AltitudeUpdateManyWithoutLeituraInput
    VelocidadeVento?: VelocidadeVentoUpdateManyWithoutLeituraInput
    DirecaoVento?: DirecaoVentoUpdateManyWithoutLeituraInput
    Precipitacao?: PrecipitacaoUpdateManyWithoutLeituraInput
    UmidadeRelativa?: UmidadeRelativaUpdateManyWithoutLeituraInput
  }

  export type LeituraUncheckedUpdateWithoutUmidadeSoloInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Temperatura?: TemperaturaUncheckedUpdateManyWithoutLeituraInput
    Pressao?: PressaoUncheckedUpdateManyWithoutLeituraInput
    Altitude?: AltitudeUncheckedUpdateManyWithoutLeituraInput
    VelocidadeVento?: VelocidadeVentoUncheckedUpdateManyWithoutLeituraInput
    DirecaoVento?: DirecaoVentoUncheckedUpdateManyWithoutLeituraInput
    Precipitacao?: PrecipitacaoUncheckedUpdateManyWithoutLeituraInput
    UmidadeRelativa?: UmidadeRelativaUncheckedUpdateManyWithoutLeituraInput
  }

  export type LeituraCreateWithoutUmidadeRelativaInput = {
    createdAt?: Date | string
    Temperatura?: TemperaturaCreateNestedManyWithoutLeituraInput
    Pressao?: PressaoCreateNestedManyWithoutLeituraInput
    Altitude?: AltitudeCreateNestedManyWithoutLeituraInput
    VelocidadeVento?: VelocidadeVentoCreateNestedManyWithoutLeituraInput
    DirecaoVento?: DirecaoVentoCreateNestedManyWithoutLeituraInput
    Precipitacao?: PrecipitacaoCreateNestedManyWithoutLeituraInput
    UmidadeSolo?: UmidadeSoloCreateNestedManyWithoutLeituraInput
  }

  export type LeituraUncheckedCreateWithoutUmidadeRelativaInput = {
    id?: number
    createdAt?: Date | string
    Temperatura?: TemperaturaUncheckedCreateNestedManyWithoutLeituraInput
    Pressao?: PressaoUncheckedCreateNestedManyWithoutLeituraInput
    Altitude?: AltitudeUncheckedCreateNestedManyWithoutLeituraInput
    VelocidadeVento?: VelocidadeVentoUncheckedCreateNestedManyWithoutLeituraInput
    DirecaoVento?: DirecaoVentoUncheckedCreateNestedManyWithoutLeituraInput
    Precipitacao?: PrecipitacaoUncheckedCreateNestedManyWithoutLeituraInput
    UmidadeSolo?: UmidadeSoloUncheckedCreateNestedManyWithoutLeituraInput
  }

  export type LeituraCreateOrConnectWithoutUmidadeRelativaInput = {
    where: LeituraWhereUniqueInput
    create: XOR<LeituraCreateWithoutUmidadeRelativaInput, LeituraUncheckedCreateWithoutUmidadeRelativaInput>
  }

  export type LeituraUpsertWithoutUmidadeRelativaInput = {
    update: XOR<LeituraUpdateWithoutUmidadeRelativaInput, LeituraUncheckedUpdateWithoutUmidadeRelativaInput>
    create: XOR<LeituraCreateWithoutUmidadeRelativaInput, LeituraUncheckedCreateWithoutUmidadeRelativaInput>
  }

  export type LeituraUpdateWithoutUmidadeRelativaInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Temperatura?: TemperaturaUpdateManyWithoutLeituraInput
    Pressao?: PressaoUpdateManyWithoutLeituraInput
    Altitude?: AltitudeUpdateManyWithoutLeituraInput
    VelocidadeVento?: VelocidadeVentoUpdateManyWithoutLeituraInput
    DirecaoVento?: DirecaoVentoUpdateManyWithoutLeituraInput
    Precipitacao?: PrecipitacaoUpdateManyWithoutLeituraInput
    UmidadeSolo?: UmidadeSoloUpdateManyWithoutLeituraInput
  }

  export type LeituraUncheckedUpdateWithoutUmidadeRelativaInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Temperatura?: TemperaturaUncheckedUpdateManyWithoutLeituraInput
    Pressao?: PressaoUncheckedUpdateManyWithoutLeituraInput
    Altitude?: AltitudeUncheckedUpdateManyWithoutLeituraInput
    VelocidadeVento?: VelocidadeVentoUncheckedUpdateManyWithoutLeituraInput
    DirecaoVento?: DirecaoVentoUncheckedUpdateManyWithoutLeituraInput
    Precipitacao?: PrecipitacaoUncheckedUpdateManyWithoutLeituraInput
    UmidadeSolo?: UmidadeSoloUncheckedUpdateManyWithoutLeituraInput
  }

  export type TemperaturaUpdateWithoutLeituraInput = {
    sensor?: StringFieldUpdateOperationsInput | string
    valor?: IntFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    ordemGrandeza?: IntFieldUpdateOperationsInput | number
  }

  export type TemperaturaUncheckedUpdateWithoutLeituraInput = {
    id?: IntFieldUpdateOperationsInput | number
    sensor?: StringFieldUpdateOperationsInput | string
    valor?: IntFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    ordemGrandeza?: IntFieldUpdateOperationsInput | number
  }

  export type TemperaturaUncheckedUpdateManyWithoutTemperaturaInput = {
    id?: IntFieldUpdateOperationsInput | number
    sensor?: StringFieldUpdateOperationsInput | string
    valor?: IntFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    ordemGrandeza?: IntFieldUpdateOperationsInput | number
  }

  export type PressaoUpdateWithoutLeituraInput = {
    sensor?: StringFieldUpdateOperationsInput | string
    valor?: IntFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    ordemGrandeza?: IntFieldUpdateOperationsInput | number
  }

  export type PressaoUncheckedUpdateWithoutLeituraInput = {
    id?: IntFieldUpdateOperationsInput | number
    sensor?: StringFieldUpdateOperationsInput | string
    valor?: IntFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    ordemGrandeza?: IntFieldUpdateOperationsInput | number
  }

  export type PressaoUncheckedUpdateManyWithoutPressaoInput = {
    id?: IntFieldUpdateOperationsInput | number
    sensor?: StringFieldUpdateOperationsInput | string
    valor?: IntFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    ordemGrandeza?: IntFieldUpdateOperationsInput | number
  }

  export type AltitudeUpdateWithoutLeituraInput = {
    sensor?: StringFieldUpdateOperationsInput | string
    valor?: IntFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    ordemGrandeza?: IntFieldUpdateOperationsInput | number
  }

  export type AltitudeUncheckedUpdateWithoutLeituraInput = {
    id?: IntFieldUpdateOperationsInput | number
    sensor?: StringFieldUpdateOperationsInput | string
    valor?: IntFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    ordemGrandeza?: IntFieldUpdateOperationsInput | number
  }

  export type AltitudeUncheckedUpdateManyWithoutAltitudeInput = {
    id?: IntFieldUpdateOperationsInput | number
    sensor?: StringFieldUpdateOperationsInput | string
    valor?: IntFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    ordemGrandeza?: IntFieldUpdateOperationsInput | number
  }

  export type VelocidadeVentoUpdateWithoutLeituraInput = {
    sensor?: StringFieldUpdateOperationsInput | string
    media?: IntFieldUpdateOperationsInput | number
    maximo?: IntFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    ordemGrandeza?: IntFieldUpdateOperationsInput | number
  }

  export type VelocidadeVentoUncheckedUpdateWithoutLeituraInput = {
    id?: IntFieldUpdateOperationsInput | number
    sensor?: StringFieldUpdateOperationsInput | string
    media?: IntFieldUpdateOperationsInput | number
    maximo?: IntFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    ordemGrandeza?: IntFieldUpdateOperationsInput | number
  }

  export type VelocidadeVentoUncheckedUpdateManyWithoutVelocidadeVentoInput = {
    id?: IntFieldUpdateOperationsInput | number
    sensor?: StringFieldUpdateOperationsInput | string
    media?: IntFieldUpdateOperationsInput | number
    maximo?: IntFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    ordemGrandeza?: IntFieldUpdateOperationsInput | number
  }

  export type DirecaoVentoUpdateWithoutLeituraInput = {
    sensor?: StringFieldUpdateOperationsInput | string
    valor?: IntFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    ordemGrandeza?: IntFieldUpdateOperationsInput | number
  }

  export type DirecaoVentoUncheckedUpdateWithoutLeituraInput = {
    id?: IntFieldUpdateOperationsInput | number
    sensor?: StringFieldUpdateOperationsInput | string
    valor?: IntFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    ordemGrandeza?: IntFieldUpdateOperationsInput | number
  }

  export type DirecaoVentoUncheckedUpdateManyWithoutDirecaoVentoInput = {
    id?: IntFieldUpdateOperationsInput | number
    sensor?: StringFieldUpdateOperationsInput | string
    valor?: IntFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    ordemGrandeza?: IntFieldUpdateOperationsInput | number
  }

  export type PrecipitacaoUpdateWithoutLeituraInput = {
    sensor?: StringFieldUpdateOperationsInput | string
    valor?: IntFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    ordemGrandeza?: IntFieldUpdateOperationsInput | number
  }

  export type PrecipitacaoUncheckedUpdateWithoutLeituraInput = {
    id?: IntFieldUpdateOperationsInput | number
    sensor?: StringFieldUpdateOperationsInput | string
    valor?: IntFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    ordemGrandeza?: IntFieldUpdateOperationsInput | number
  }

  export type PrecipitacaoUncheckedUpdateManyWithoutPrecipitacaoInput = {
    id?: IntFieldUpdateOperationsInput | number
    sensor?: StringFieldUpdateOperationsInput | string
    valor?: IntFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    ordemGrandeza?: IntFieldUpdateOperationsInput | number
  }

  export type UmidadeSoloUpdateWithoutLeituraInput = {
    sensor?: StringFieldUpdateOperationsInput | string
    valor?: IntFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    ordemGrandeza?: IntFieldUpdateOperationsInput | number
  }

  export type UmidadeSoloUncheckedUpdateWithoutLeituraInput = {
    id?: IntFieldUpdateOperationsInput | number
    sensor?: StringFieldUpdateOperationsInput | string
    valor?: IntFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    ordemGrandeza?: IntFieldUpdateOperationsInput | number
  }

  export type UmidadeSoloUncheckedUpdateManyWithoutUmidadeSoloInput = {
    id?: IntFieldUpdateOperationsInput | number
    sensor?: StringFieldUpdateOperationsInput | string
    valor?: IntFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    ordemGrandeza?: IntFieldUpdateOperationsInput | number
  }

  export type UmidadeRelativaUpdateWithoutLeituraInput = {
    sensor?: StringFieldUpdateOperationsInput | string
    valor?: IntFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    ordemGrandeza?: IntFieldUpdateOperationsInput | number
  }

  export type UmidadeRelativaUncheckedUpdateWithoutLeituraInput = {
    id?: IntFieldUpdateOperationsInput | number
    sensor?: StringFieldUpdateOperationsInput | string
    valor?: IntFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    ordemGrandeza?: IntFieldUpdateOperationsInput | number
  }

  export type UmidadeRelativaUncheckedUpdateManyWithoutUmidadeRelativaInput = {
    id?: IntFieldUpdateOperationsInput | number
    sensor?: StringFieldUpdateOperationsInput | string
    valor?: IntFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    ordemGrandeza?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.DMMF.Document;
}